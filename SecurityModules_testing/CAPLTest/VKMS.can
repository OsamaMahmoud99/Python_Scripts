/*@!Encoding:65001*/
includes
{
  
  #include "Generics\Generics_CAN_Functions.cin"
  #include "Generics\Generics_TestCase.cin"
  #include "Generics\Generics_DiagSupportFunctions.cin"
  #include "Generics\Generics_Diag.cin"
}

variables
{
  byte pssHash[16];
  
  long status = 1; 
  char flag = 0;
  byte challenge[16]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  byte IdentityHash_UsedDLC[16];
  
  byte Verification_Hash_UsedDLC_Request[21]={0x31,0x01,0xC0,0x0B,0x00,0xEA,0x34,0x3A,0x3B,0xBB,0xC1,0xA8,0x8C,0x62,0xC2,0x1D,0x7C,0x80,0x85,0x92,0x37};

  
  byte Verification_Hash_ResetDLC_Request[21] = {0x31,0x01,0xC0,0x0B,0x00,0x05,0x69,0xA8,0x32,0x03,0x88,0x15,0x35,0xD4,0x94,0xE5,0xA4,0x7C,0x50,0x9E,0x4F};
  byte Verification_Hash_ChangedKey_Request[21]={0x31,0x01,0xC0,0x0B,0x00,0x8F,0x8E,0x90,0xF1,0x74,0x7D,0xE5,0xF4,0x21,0x75,0xBC,0x40,0x9A,0xF5,0x32,0x09};
 
  byte Verification_Hash_ResetDLC[16] = {0x05,0x69,0xA8,0x32,0x03,0x88,0x15,0x35,0xD4,0x94,0xE5,0xA4,0x7C,0x50,0x9E,0x4F};
  byte Verification_Hash_UsedDLC[16]={0xEA,0x34,0x3A,0x3B,0xBB,0xC1,0xA8,0x8C,0x62,0xC2,0x1D,0x7C,0x80,0x85,0x92,0x37};
  
  byte VIN_Number_UsedDLC_Expected[17]={0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x41,0x42,0x43,0x44,0x45,0x46,0x47};
  byte VIN_Number_ResetDLC_Expected[17] = {0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D};

  byte RequestDownload_usedDLC[187]={0x31, 0x01, 0xC0, 0x0A,0x00,0x01,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x00,0x01,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x05,0x05,0x05,0x00,0x06,0xEA,0x34,0x3A,0x3B,0xBB,0xC1,0xA8,0x8C,0x62,0xC2,0x1D,0x7C,0x80,0x85,0x92,0x37,0x04,0x53,0xE3,0xAC,0x67,0x99,0x5A,0xD1,0xB3,0x34,0x5B,0x4A,0x4F,0x9B,0x27,0xF7,0xE5,0xCF,0xD6,0xA1,0xFD,0x59,0x9D,0xB1,0x59,0x22,0xB0,0x30,0x59,0x13,0xEF,0x76,0x9E,0x05,0x5F,0x3A,0x7D,0xD0,0xDB,0x84,0x3D,0xAA,0xAD,0x07,0x8D,0xE6,0xF6,0x72,0x79,0x21,0x03,0x1F,0xD7,0x6C,0xF7,0xCC,0x3C,0x91,0xF9,0x79,0x57,0xE2,0xF4,0x02,0x7A,0x3B,0x1B,0x7A,0x2C,0x8C,0x52,0x92,0x39,0x20,0xC2,0x1F,0xC6,0xD0,0x6B,0x1D,0xE2,0x31,0xC1,0x8E,0x57,0x65,0xA3,0xCE,0x16,0x5E,0xED,0x25,0xBA,0x97,0x79,0xF8,0xF5,0x09,0xD7,0xC5,0xEC,0x41,0x2C,0x45,0x34,0x4C,0x29,0x9D,0x46,0xF2,0x01,0xDE,0xFB,0xD0,0x85,0x64,0x34,0xC4,0x7A,0x9F,0x34,0x18,0x22,0x87,0x44,0x30,0xDA,0xFA,0x17};
  byte RequestDownload_usedDLC_wrongGMac[187]={0x31, 0x01, 0xC0, 0x0A,0x00,0x01,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x00,0x01,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x05,0x05,0x05,0x00,0x06,0xEA,0x34,0x3A,0x3B,0xBB,0xC1,0xA8,0x8C,0x62,0xC2,0x1D,0x7C,0x80,0x85,0x92,0x37,0x04,0x53,0xE3,0xAC,0x67,0x99,0x5A,0xD1,0xB3,0x34,0x5B,0x4A,0x4F,0x9B,0x27,0xF7,0xE5,0xCF,0xD6,0xA1,0xFD,0x59,0x9D,0xB1,0x59,0x22,0xB0,0x30,0x59,0x13,0xEF,0x76,0x9E,0x05,0x5F,0x3A,0x7D,0xD0,0xDB,0x84,0x3D,0xAA,0xAD,0x07,0x8D,0xE6,0xF6,0x72,0x79,0x21,0x03,0x1F,0xD7,0x6C,0xF7,0xCC,0x3C,0x91,0xF9,0x79,0x57,0xE2,0xF4,0x02,0x7A,0x3B,0x1B,0x7A,0x2C,0x8C,0x52,0x92,0x39,0x20,0xC2,0x1F,0xC6,0xD0,0x6B,0x1D,0xE2,0x31,0xC1,0x8E,0x57,0x65,0xA3,0xCE,0x16,0x5E,0xED,0x25,0xBA,0x97,0x79,0xF8,0xF5,0x09,0xD7,0xC5,0xEC,0x41,0x2C,0x45,0x34,0x4C,0x29,0x9D,0x46,0xF2,0x01,0xDE,0xFB,0xD0,0x85,0x64,0x34,0xC4,0x7A,0x9F,0x34,0x18,0x22,0x87,0x44,0x30,0xDA,0xFA,0x00};

  byte RequestDownload_resetDLC[115]={0x31, 0x01, 0xC0, 0x0A,0x00,0x01,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xA5,0xDB,0x3F,0xD0,0xAB,0x5F,0x2F,0x31,0xE2,0x9F,0x1B,0x6A,0xE4,0x67,0x40,0x84,0x01,0xEA,0x33,0x3A,0xC1,0xC5,0x32,0xA6,0x6C,0x61,0x74,0x3C,0x12,0x9D,0x78,0xA6,0xB1,0xB5,0x6E,0xAE,0x32,0x11,0x06,0x87,0x11,0x83,0x6E,0x17,0xD4,0x62,0x3D,0xE2,0x74,0xFF,0x09,0x71,0xEA,0xA6,0xFD,0x59,0x24,0x98,0x77,0x9F,0xAD,0x86,0x1E,0x63,0x75,0xD7,0xBA,0x99,0x3B,0x60,0x0C,0x4D,0xCB};

  byte KeyList_IDs[16];
  dword NumberOfKeys;
  
  byte VKMS_FIRST_DOWNLOAD_CONTAINER_REQUIRED_DTC[3] = {0x05 , 0x00 , 0x06};
  byte VKMS_new_download_container_required_due_to_vehicle_change_DTC[3] = {0x05 , 0x00 , 0x05};
  byte Vkms_application_requested_missing_key_DTC[3] = {0x05 , 0x00 , 0x08};
  byte Vkms_first_dlc_required_DTC[3] = {0x05 , 0x00 , 0x06};
  
  int requestDownload_result = 0x24;
  int requestDownload_wrongMac_result = 0x1E;  //VKMS_ERR_DLC_INVALID_MAC
  
  byte ECU_Training_Counter_UsedDLC_Expected[3] = {0x00, 0x00 , 0x01};
  byte ECU_Training_Counter_ResetDLC_Expected[3]= {0x00, 0x00,0x00};
  byte Vkms_TrainingCounter_DID[2]= {0x2C , 0x56};
  byte Vkms_KeyList_DID[2] = {0x2C, 0x60};
  byte Vkms_MissingKeyList_DID[2] = {0x2C , 0x57};
  
  byte RequestDownload_UsedDLC_MissingKey[163]={0x31, 0x01, 0xC0, 0x0A,0x00,0x01,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x00,0x01,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x05,0x05,0x05,0x00,0x06,0x5B,0x81,0x0E,0xE1,0x14,0x21,0xB8,0x36,0x79,0x1E,0x8E,0x94,0xA4,0xB7,0x8C,0x78,0x03,0x53,0xE3,0xAC,0x67,0x99,0x5A,0xD1,0xB3,0x34,0x5B,0x4A,0x4F,0x9B,0x27,0xF7,0xE5,0xCF,0xD6,0xA1,0xFD,0x59,0x9D,0xB1,0x59,0x22,0xB0,0x30,0x59,0x13,0xEF,0x76,0x9E,0x05,0x5F,0x3A,0x7D,0xD0,0xDB,0x84,0x3D,0xAA,0xAD,0x07,0x8D,0xE6,0xF6,0x72,0x79,0x21,0x03,0x1F,0xD7,0x6C,0xF7,0xCC,0x3C,0x91,0xF9,0x79,0x57,0xE2,0xF4,0x02,0x7A,0x3B,0x1B,0x7A,0x2C,0x8C,0x52,0x92,0x39,0x20,0xC2,0x1F,0xC6,0xD0,0x6B,0x1D,0xE2,0x31,0xC1,0x8E,0x57,0x65,0xA3,0xCE,0x16,0x3E,0xE7,0x99,0xB2,0x06,0xD5,0x0F,0x82,0xB9,0x83,0x03,0x09,0xAC,0xA8,0x90,0xFC};
  byte RequestDownload_UsedDLC_OneChangedKey[187]={0x31, 0x01, 0xC0, 0x0A,0x00,01,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x00,0x01,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x05,0x05,0x05,0x00,0x06,0x8F,0x8E,0x90,0xF1,0x74,0x7D,0xE5,0xF4,0x21,0x75,0xBC,0x40,0x9A,0xF5,0x32,0x09,0x04,0x53,0xE3,0xAC,0x67,0x99,0x5A,0xD1,0xB3,0x34,0x5B,0x4A,0x4F,0x9B,0x27,0xF7,0xE5,0xCF,0xD6,0xA1,0xFD,0x59,0x9D,0xB1,0x59,0x22,0xB0,0x30,0x59,0x13,0xEF,0x76,0x9E,0x05,0x5F,0x3A,0x7D,0xD0,0xDB,0x84,0x3D,0xAA,0xAD,0x07,0x8D,0xE6,0xF6,0x72,0x79,0x21,0x03,0x1F,0xD7,0x6C,0xF7,0xCC,0x3C,0x91,0xF9,0x79,0x57,0xE2,0xF4,0x02,0x7A,0x3B,0x1B,0x7A,0x2C,0x8C,0x52,0x92,0x39,0x20,0xC2,0x1F,0xC6,0xD0,0x6B,0x1D,0xE2,0x31,0xC1,0x8E,0x57,0x65,0xA3,0xCE,0x16,0x5E,0xED,0x25,0xBA,0x97,0x79,0xF8,0xF5,0x09,0xD7,0xC5,0xEC,0x41,0x2C,0x45,0x34,0x4C,0x29,0x9D,0x46,0xF2,0x01,0xDE,0x51,0xF6,0x85,0xD9,0x36,0x16,0x43,0xBE,0x69,0x25,0xFD,0x9E,0x7A,0x38,0xAF,0xBB,0x76};
  byte RequestDownload_UsedDLC_ReadableKey[187] = {0x31, 0x01, 0xC0, 0x0A,0x00,0x01,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x00,0x01,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x05,0x05,0x05,0x00,0x06,0x59,0x55,0x8E,0x8D,0x87,0x83,0x08,0xB0,0x4B,0x4F,0x35,0x2E,0x7B,0x79,0x0F,0x53,0x04,0x53,0xE3,0xAC,0x67,0x99,0x5A,0xD1,0xB3,0x34,0x5B,0x4A,0x4F,0x9B,0x27,0xF7,0xE5,0xCF,0xD6,0xA1,0xFD,0x59,0x9D,0xB1,0x59,0x22,0xB0,0x30,0x59,0x13,0xEF,0x76,0x9E,0x05,0x5F,0x3A,0x7D,0xD0,0xDB,0x84,0x3D,0xAA,0xAD,0x07,0x8D,0xE6,0xF6,0x72,0x79,0x21,0x03,0x1F,0xD7,0x6C,0xF7,0xCC,0x3C,0x91,0xF9,0x79,0x57,0xE2,0xF4,0x02,0x7A,0x3B,0x1B,0x7A,0x2C,0x8C,0x52,0x92,0x39,0x20,0xC2,0x1F,0xC6,0xD0,0x6B,0x1D,0xE2,0x31,0xC1,0x8E,0x57,0x65,0xA3,0xCE,0x16,0x5E,0xED,0x25,0xBA,0x97,0x78,0xF8,0xF5,0x09,0xD7,0xC5,0xEC,0x41,0x2C,0x45,0x34,0x4C,0x29,0x9D,0x46,0xF2,0x01,0xDE,0xFB,0x4C,0x1F,0x92,0x5F,0x28,0x2D,0x59,0x1B,0x7F,0xBE,0x30,0x54,0xAA,0xD5,0x0B,0xFF};
  dword STARTUP_TIME = 2000;
  
  byte PSS_Hash_ResetDLC_Expected[22] = {0x71, 0x03, 0xC0, 0x0D, 0x24, 0x00,0x14,0x85,0x52,0xB5,0x87,0x93,0xB4,0xE3,0x58,0xF4,0xD1,0xD1,0xB9,0x26,0x9C,0xC9};
  byte PSS_Hash_UsedDLC_Expected[22] = {0x71, 0x03, 0xC0, 0x0D, 0x24, 0x00,0xF7,0xF8,0xCA,0x16,0xD6,0xB6,0x98,0x0C,0x13,0xFC,0xE4,0x2E,0x30,0x48,0xE5,0x66};

  byte Identity_Hash_Request[21]={0x31, 0x01, 0xC0, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  byte Identity_Hash_UsedDLC_Expected[22];
  byte Identity_Hash_ResetDLC_Expected[22];
  byte Identity_Hash_UsedDLC[32];
  byte Identity_Hash_ResetDLC[32];
  int k;
  int f=0;
  
  
  int value;
  double time1;
  double time2;
  double time3;
  double time4;
  double time = 0;
  double time_resetdlc=0;
  double MinTime_useddlc = 6000;
  double MaxTime_useddlc = 0;
  double MinTime_resetdlc = 6000;
  double MaxTime_resetdlc = 0;
  byte MajorVersion = 0x02;
  byte MinorVersion = 0x07;
  byte BugFixVersion = 0x02;
  byte MasterKey1 =0xFF;
  byte MasterKey2 =0xFF;
  byte MasterKey3 =0xFF;
  byte identifier1 = 0xFF;
  byte identifier2 =0xFF;
  int j=0;
  byte Key_status;
  int wrong_gmac = 0;
  int correct_gmac = 1;
  byte key_3[19]={0x62,0xEE, 0x00, 0xAA,0x17,0x15,0xBB,0x17,0x15,0xBB,0x17,0x15,0xBB,0x17,0x15,0xBB,0x17,0x15,0xAA};
  
  dword timeout_1000_ms=1000;
  dword timeout_2000_ms=2000;
  dword timeout_5000_ms=5000;
  dword timeout_10000_ms = 10000;
  dword timeout_6000_ms = 6000;
  dword timeout_50_ms = 50;
  dword timeout_100_ms = 100;
  
  int VKMS_ERR_DLC_MISSING_KEY = 36;
  int VKMS_ERR_BUSY = 23;
  int VKMS_ERR_DLC_VERIFICATION_MISMATCH = 33;
  int VKMS_ERR_DLC_DEPRECATED = 32;
  int VKMS_ERR_DLC_INVALID_MAC = 30;
   
  byte VIN[21];
  byte Fazit_ID[23];
  // Split the string into pairs of characters
  char hex_pair[3]; // Each pair consists of two hex digits and a null terminator
  
  byte SOK_TimeServer[3] = {0x05,0x00,0x01};
  byte SOK_Signature[3] = {0x05,0x00,0x02};
  
  
  char file_path[256] = ".\\Flashing_Scripts\\counter.txt";
  int counter_value;
  dword glbHandle = 0;
  char command[256];
}
  

void check_VIN_Number_UsedDLC()
{
  /* check VIN number */
  setSignalwithValue(VIN_1_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[0], "set byte of VIN number");
  setSignalwithValue(VIN_2_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[1], "set byte of VIN number");
  setSignalwithValue(VIN_3_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[2], "set byte of VIN number");
  setSignalwithValue(VIN_4_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[3], "set byte of VIN number");
  setSignalwithValue(VIN_5_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[4], "set  byte of VIN number");
  setSignalwithValue(VIN_6_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[5], "set  byte of VIN number");
  setSignalwithValue(VIN_7_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[6], "set  byte of VIN number");
  setSignalwithValue(VIN_8_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[7], "set  byte of VIN number");
  setSignalwithValue(VIN_9_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[8], "set  byte of VIN number");
  setSignalwithValue(VIN_10_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[9], "set  byte of VIN number");
  setSignalwithValue(VIN_11_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[10], "set  byte of VIN number");
  setSignalwithValue(VIN_12_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[11], "set  byte of VIN number");
  setSignalwithValue(VIN_13_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[12], "set  byte of VIN number");
  setSignalwithValue(VIN_14_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[13], "set  byte of VIN number");
  setSignalwithValue(VIN_15_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[14], "set  byte of VIN number");
  setSignalwithValue(VIN_16_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[15], "set  byte of VIN number");
  setSignalwithValue(VIN_17_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_UsedDLC_Expected[16], "set  byte of VIN number");
  
  testWaitForTimeout(timeout_1000_ms);
 
  VIN[0] = 0x62;
  VIN[1] = 0x2C;
  VIN[2] = 0x55;
  VIN[3] = 0x00;
  VIN[4] = getSignal(VIN_1_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[5] = getSignal(VIN_2_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[6] = getSignal(VIN_3_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[7] = getSignal(VIN_4_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[8] = getSignal(VIN_5_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[9] = getSignal(VIN_6_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[10] = getSignal(VIN_7_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[11] = getSignal(VIN_8_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[12] = getSignal(VIN_9_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[13] = getSignal(VIN_10_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[14] = getSignal(VIN_11_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[15] = getSignal(VIN_12_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[16] = getSignal(VIN_13_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[17] = getSignal(VIN_14_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[18] = getSignal(VIN_15_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[19] = getSignal(VIN_16_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[20] = getSignal(VIN_17_XIX_WFS_02_XIX_HCP4_CANFD01);
  
  /*for(i=0; i<17; i++)
  {
   write("VIN is %X ",VIN[i]); 
  }*/
  
  snprintf(BufferString, 100, "0x22 0x2C 0x55");
  sendDiagnosticsRequest(BufferString , "check result");
  
  checkDiagnosticsResponse_array(VIN,21,timeout_2000_ms, "Check positive response for request");
}

void check_VIN_Number_ResetDLC()
{
  /* check VIN number */
  setSignalwithValue(VIN_1_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[0], "set byte of VIN number");
  setSignalwithValue(VIN_2_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[1], "set byte of VIN number");
  setSignalwithValue(VIN_3_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[2], "set byte of VIN number");
  setSignalwithValue(VIN_4_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[3], "set byte of VIN number");
  setSignalwithValue(VIN_5_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[4], "set  byte of VIN number");
  setSignalwithValue(VIN_6_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[5], "set  byte of VIN number");
  setSignalwithValue(VIN_7_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[6], "set  byte of VIN number");
  setSignalwithValue(VIN_8_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[7], "set  byte of VIN number");
  setSignalwithValue(VIN_9_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[8], "set  byte of VIN number");
  setSignalwithValue(VIN_10_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[9], "set  byte of VIN number");
  setSignalwithValue(VIN_11_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[10], "set  byte of VIN number");
  setSignalwithValue(VIN_12_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[11], "set  byte of VIN number");
  setSignalwithValue(VIN_13_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[12], "set  byte of VIN number");
  setSignalwithValue(VIN_14_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[13], "set  byte of VIN number");
  setSignalwithValue(VIN_15_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[14], "set  byte of VIN number");
  setSignalwithValue(VIN_16_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[15], "set  byte of VIN number");
  setSignalwithValue(VIN_17_XIX_WFS_02_XIX_HCP4_CANFD01 , VIN_Number_ResetDLC_Expected[16], "set  byte of VIN number");
  
  testWaitForTimeout(timeout_1000_ms);
 
  VIN[0] = 0x62;
  VIN[1] = 0x2C;
  VIN[2] = 0x55;
  VIN[3] = 0x00;
  VIN[4] = getSignal(VIN_1_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[5] = getSignal(VIN_2_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[6] = getSignal(VIN_3_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[7] = getSignal(VIN_4_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[8] = getSignal(VIN_5_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[9] = getSignal(VIN_6_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[10] = getSignal(VIN_7_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[11] = getSignal(VIN_8_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[12] = getSignal(VIN_9_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[13] = getSignal(VIN_10_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[14] = getSignal(VIN_11_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[15] = getSignal(VIN_12_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[16] = getSignal(VIN_13_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[17] = getSignal(VIN_14_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[18] = getSignal(VIN_15_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[19] = getSignal(VIN_16_XIX_WFS_02_XIX_HCP4_CANFD01);
  VIN[20] = getSignal(VIN_17_XIX_WFS_02_XIX_HCP4_CANFD01);
  
  /*for(i=0; i<17; i++)
  {
   write("VIN is %X ",VIN[i]); 
  }
  */
  
  snprintf(BufferString, 100, "0x22 0x2C 0x55");
  sendDiagnosticsRequest(BufferString , "check result");
  
  checkDiagnosticsResponse_array(VIN,21,timeout_2000_ms, "Check positive response for request");
  
}

void Download_ResetDLC()
{
      int counter;
      int error_value;
  
      
      testWaitForTimeout(100);
      /* Download used DLC*/
      sendDiagnosticsRequest_array(RequestDownload_resetDLC , 115);
      
      snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0A");
      checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
      
      counter = 0;
      error_value = VKMS_ERR_BUSY;
      while( (error_value == VKMS_ERR_BUSY) && (counter <= 5) )
      {
          testWaitForTimeout(100);
          /* check result is equal to 24: 31 03 C0 0A - TABROW_VkmsHandlDownl_Results */
          snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0A");
          sendDiagnosticsRequest(BufferString , "check result");
          snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0A 0x%02X 0x%02X",0x24,0x00);
          error_value = checkDiagnosticsResponse_returnValue(BufferString,timeout_1000_ms, "Check positive response for requestDownload_result");
          counter = counter + 1;
      }
      if( (error_value == VKMS_ERR_DLC_VERIFICATION_MISMATCH) && (counter <= 5) )
      {
        testStepFail("The calculated DLC-verificationchecksum is not consistent with the expected value inside the DLC"); 
      }
      else if((error_value == 0x20) && (counter <=5) )
      {
        testStepFail("The value of the ECU learning counter in the DLC is less than the saved value");
      }
      else if( (error_value == 0) && (counter <=5))
      {
        testStepPass("Operation successful:Expected result was equal to actual");
      }
      else if( (error_value == 0) && (counter == 6 ) )
      {
        testStepFail("timeout: downloading reset dlc takes time"); 
      }
}

void Download_UsedDLC(int gmac_status)
{
  int counter;
  int error_value;
  
  testWaitForTimeout(100);

  error_value = VKMS_ERR_BUSY;
  counter = 0;
  if(gmac_status == correct_gmac)
  {

      sendDiagnosticsRequest_array(RequestDownload_usedDLC , 187);
      
      
      snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0A");
      checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
    
      while( (error_value == VKMS_ERR_BUSY) && (counter <=5) )
      {
        testWaitForTimeout(100);
         /* check result is equal to 24: 31 03 C0 0A - TABROW_VkmsHandlDownl_Results */
        snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0A");
        sendDiagnosticsRequest(BufferString , "check result");
        
        snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0A 0x%02X 0x%02X",requestDownload_result,0x00);
        error_value = checkDiagnosticsResponse_returnValue(BufferString,timeout_1000_ms, "Check positive response for requestDownload_result");
        
        counter = counter + 1;
      }
      if( (error_value == VKMS_ERR_DLC_VERIFICATION_MISMATCH) && (counter <=5) )
      {
          testStepFail("The calculated DLC-verificationchecksum is not consistent with the expected value inside the DLC"); 
      }
      else if((error_value == 0) && (counter <=5)){
          testStepPass("Expected result was equal to actual");
      }
      else if((error_value == 0) && (counter == 6))
      {
        testStepFail("timeout: downloading used dlc with correct mac takes time");
      }
  }
  else if(gmac_status == wrong_gmac)
  {
      /* Download used DLC with wrongGMac */
      sendDiagnosticsRequest_array(RequestDownload_usedDLC_wrongGMac , 187);
    
      snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0A");
      checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
      
      while( (error_value == VKMS_ERR_BUSY) && (counter <=5) )
      {
        testWaitForTimeout(100);
         /* check result is equal to 24: 31 03 C0 0A - TABROW_VkmsHandlDownl_Results */
        snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0A");
        sendDiagnosticsRequest(BufferString , "check result");
        
        snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0A 0x%02X 0x%02X",0x14,VKMS_ERR_DLC_INVALID_MAC);
        error_value = checkDiagnosticsResponse_returnValue(BufferString,timeout_1000_ms, "Check positive response for requestDownload_result");
        
        counter = counter + 1; 
      }
      if( (error_value == VKMS_ERR_DLC_INVALID_MAC) && (counter <=5) )
      {
         testStepPass("DLC is not Handled The MAC of the DLC could not be verified."); 
      }
      else if( (error_value == 0) && (counter <=5) ){
         testStepFail("Expected result was equal to actual");
      }
      else if( (error_value == VKMS_ERR_DLC_INVALID_MAC) && (counter == 6) )
      {
        testStepFail("timeout: downloading used dlc with wrong mac takes time");
      }
     
  }
}

void Download_UsedDLC_oneChangedKey()
{
      int error_value;
      int counter;
  
      
      testWaitForTimeout(100);
      sendDiagnosticsRequest_array(RequestDownload_UsedDLC_OneChangedKey , 187);
  
      snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0A");
      checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
      
      error_value = VKMS_ERR_BUSY;
      counter = 0;  
      while((error_value == VKMS_ERR_BUSY) && (counter <= 5))
      {
        testWaitForTimeout(100);
        //write("value is %d ",error_value);
             /* check result is equal to 24: 31 03 C0 0A - TABROW_VkmsHandlDownl_Results */
        snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0A");
        sendDiagnosticsRequest(BufferString , "check result");
        
        snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0A 0x%02X 0x%02X",0x24,0x00);
        error_value = checkDiagnosticsResponse_returnValue(BufferString,timeout_1000_ms, "Check positive response for requestDownload_result");
        
        counter = counter + 1;
      }
      if((error_value == VKMS_ERR_DLC_VERIFICATION_MISMATCH) && (counter <= 5))
      {
          testStepFail("The calculated DLC-verificationchecksum is not consistent with the expected value inside the DLC"); 
      }
      else if( (error_value == 0) && (counter <= 5) ){
          testStepPass("Expected result was equal to actual DLC is handled");
      }
}

void Download_UsedDLC_ReadableKey()
{
      int error_value;
      int counter;
  
     
      testWaitForTimeout(100);
      sendDiagnosticsRequest_array(RequestDownload_UsedDLC_ReadableKey , 187);
  
      snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0A");
      checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
      
      error_value = VKMS_ERR_BUSY;
      counter = 0;
      while((error_value == VKMS_ERR_BUSY) && (counter <=5))
      {
        testWaitForTimeout(timeout_100_ms);
        //write("value is %d ",error_value);
        /* check result is equal to 24: 31 03 C0 0A - TABROW_VkmsHandlDownl_Results */
        snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0A");
        sendDiagnosticsRequest(BufferString , "check result");
        
        snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0A 0x%02X 0x%02X",0x24,0x00);
        error_value = checkDiagnosticsResponse_returnValue(BufferString,timeout_1000_ms, "Check positive response for requestDownload_result");
        
        counter = counter + 1;
      }
      if((error_value == VKMS_ERR_DLC_VERIFICATION_MISMATCH) && (counter <= 5))
      {
          testStepFail("The calculated DLC-verificationchecksum is not consistent with the expected value inside the DLC"); 
      }
      else if( (error_value == 0) && (counter <= 5) ){
          testStepPass("Expected result was equal to actual DLC is handled");
      }
      else if( (error_value == 0) && (counter == 6 ) )
      {
        testStepFail("timeout: downloading dlc one readable key takes time"); 
      }
}

void Download_UsedDLC_oneMissingKey()
{
      int counter;
      int error_value;
  
      testWaitForTimeout(100);
      
      sendDiagnosticsRequest_array(RequestDownload_UsedDLC_MissingKey , 163);
      
      snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0A");
      checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
      
      counter = 0;
      error_value = VKMS_ERR_BUSY;
      while((error_value == VKMS_ERR_BUSY) && (counter <= 5))
      {
        testWaitForTimeout(100);
        /* check result is equal to 24: 31 03 C0 0A - TABROW_VkmsHandlDownl_Results */
        snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0A");
        sendDiagnosticsRequest(BufferString , "check result");
        
        snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0A 0x%02X 0x%02X",0x14,VKMS_ERR_DLC_MISSING_KEY);
        error_value = checkDiagnosticsResponse_returnValue(BufferString,timeout_1000_ms, "Check positive response for requestDownload_result");
        counter = counter +1;
      }
      if((error_value == VKMS_ERR_DLC_MISSING_KEY) && (counter <= 5) ){
          testStepPass("VKMS Error Code VKMS_ERR_DLC_MISSING_KEY");
      }
      else if((error_value == VKMS_ERR_DLC_VERIFICATION_MISMATCH) && (counter <= 5) )
      {
          testStepFail("The calculated DLC-verificationchecksum is not consistent with the expected value inside the DLC");  
      }
      else if( (error_value == 0) && (counter == 6 ) )
      {
        testStepFail("timeout: downloading reset dlc takes time"); 
      }
      else
      {
          write("error_value = 0x%02X",error_value);
          testStepFail("VKMS Error Code E Not Ok");  
      }
      
}
void Start_ExtendedSession()
{
  snprintf(BufferString, 100, "0x10 0x03");
  sendDiagnosticsRequest(BufferString , "start extended session");
  
   
  snprintf(BufferString, 100, "0x50 0x03 0x00 0x32 0x01 0xF4");
  checkDiagnosticsResponse(BufferString , 1000, "check positive response for start extended session");
}

void Get_PssHash_UsedDLC()
{
  testWaitForTimeout(100);

  /* start get pss hash */
  snprintf(BufferString, 100, "0x31 0x01 0xC0 0x0D 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0D");
  checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
  
  testWaitForTimeout(100);

  snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0D");
  sendDiagnosticsRequest(BufferString , "check result");
  
  /* Check positive response for pss Hash */
  checkDiagnosticsResponse_array(PSS_Hash_UsedDLC_Expected,22,1000, "Check positive response for pss Hash");  
}

int Get_PssHash_ResetDLC()
{ int error_value;
  snprintf(BufferString, 100, "0x31 0x01 0xC0 0x0D 0x00");
  sendDiagnosticsRequest(BufferString , "send start pss hash request ");
  
  snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0D");
  checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
      testWaitForTimeout(100);

  snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0D");
  sendDiagnosticsRequest(BufferString , "check result");
  
  /* Check positive response for pss Hash */
  error_value = checkDiagnosticsResponse_array_returnError(PSS_Hash_ResetDLC_Expected,22,1000, "Check positive response for pss Hash");  

  //write("error pss hash value is %d",error_value);
  return error_value;
}

void Get_VerificationHash_UsedDLC()
{
  int error_value;
  error_value = VKMS_ERR_BUSY;
  
  /* verification hash start */
  sendDiagnosticsRequest_array(Verification_Hash_UsedDLC_Request , 21); 
  
  snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0B");
  checkDiagnosticsResponse(BufferString , timeout_2000_ms, "check positive response for start verification hash");
  testWaitForTimeout(100);

  while(error_value == VKMS_ERR_BUSY)
  {
      /* verification hash result */
    snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0B");
    sendDiagnosticsRequest(BufferString , "check result");
    
    snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0B 0x%02X 0x%02X",0x24 , 0x00);
    error_value = checkDiagnosticsResponse_returnValue(BufferString , timeout_1000_ms, "check positive response for start extended session");
    
    testWaitForTimeout(100);
  }
  if(error_value == VKMS_ERR_DLC_VERIFICATION_MISMATCH)
  {
      testStepFail("The calculated DLC-verificationchecksum is not consistent with the expected value inside the DLC."); 
  }
  else if(error_value == 0)
  {
      testStepPass("Actual verification hash result for used dlc was equal to Expected result");
  }
}

void Get_VerificationHash_ResetDLC()
{
  int error_value;
  error_value = VKMS_ERR_BUSY;
  
  sendDiagnosticsRequest_array(Verification_Hash_ResetDLC_Request , 21);
  
  snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0B");
  checkDiagnosticsResponse(BufferString , timeout_2000_ms, "check positive response for start verification hash");
  testWaitForTimeout(100);

  while(error_value == VKMS_ERR_BUSY)
  {
    snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0B");
    sendDiagnosticsRequest(BufferString , "check result");
    
    snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0B 0x%02X 0x%02X",0x24 , 0x00);
    error_value = checkDiagnosticsResponse_returnValue(BufferString , timeout_1000_ms, "check positive response for check verification hash result");
    
    testWaitForTimeout(100);
  }
  if(error_value == VKMS_ERR_DLC_VERIFICATION_MISMATCH)
  {
      testStepFail("The calculated DLC-verificationchecksum is not consistent with the expected value inside the DLC."); 
  }
  else if(error_value == 0)
  {
      testStepPass("Actual verification hash result for reset dlc was equal to Expected result");
  }
  
}

void Get_VerificationHash_ChangedKey()
{
  int error_value;
  error_value = VKMS_ERR_BUSY;
  
  sendDiagnosticsRequest_array(Verification_Hash_ChangedKey_Request , 21);
  
  
  snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0B");
  checkDiagnosticsResponse(BufferString , timeout_2000_ms, "check positive response for start verification hash");
  testWaitForTimeout(100);


  while(error_value == VKMS_ERR_BUSY)
  {
    snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0B");
    sendDiagnosticsRequest(BufferString , "check result");
    
    snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0B 0x%02X 0x%02X",0x24 , 0x00);
    error_value = checkDiagnosticsResponse_returnValue(BufferString , timeout_1000_ms, "check positive response for start extended session");
    
    testWaitForTimeout(100);
  }
  if(error_value == VKMS_ERR_DLC_VERIFICATION_MISMATCH)
  {
      testStepFail("The calculated DLC-verificationchecksum is not consistent with the expected value inside the DLC."); 
  }
  else if(error_value == 0)
  {
      testStepPass("Actual result was equal to Expected result_crypto operation is executed");
  }
}

void Get_IdentityHash_UsedDLC()
{
  Get_IdentityHash_UsedDLC_test();
  
  Identity_Hash_UsedDLC_Expected[0] = 0x71;
  Identity_Hash_UsedDLC_Expected[1] = 0x03;
  Identity_Hash_UsedDLC_Expected[2] = 0xC0;
  Identity_Hash_UsedDLC_Expected[3] = 0x0C;
  Identity_Hash_UsedDLC_Expected[4] = 0x24;
  Identity_Hash_UsedDLC_Expected[5] = 0x00;
  
  for(k=0; k<16; k++)
  {
    Identity_Hash_UsedDLC_Expected[k+6] = Identity_Hash_UsedDLC[k];
  }
  testWaitForTimeout(100);

  sendDiagnosticsRequest_array(Identity_Hash_Request, 21); 
  snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0C");
  checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
  
  testWaitForTimeout(100);
  
  snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0C");
  sendDiagnosticsRequest(BufferString , "check result");
  
  checkDiagnosticsResponse_array(Identity_Hash_UsedDLC_Expected,22,1000, "Check positive response for Identity Hash"); 
  }

void Get_IdentityHash_UsedDLC_test()
{
  byte used_key[32] = { 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
   
  byte data[55];
  byte challenge[16]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
  dword result = 255;
  int i;
  char actual_resp_string[1000]="";
  char string_actual[1000]="The Fazit ID is :";
  
  snprintf(BufferString, 100, "0x22 0xF1 0x7C");
  sendDiagnosticsRequest(BufferString , "Read FazitID");

  checkDiagnosticsResponse_returnArray(Fazit_ID , 26 , 1000);
  
  for(i=0; i<23; i++)
  {
    //write("Fazitid_after is %X",Fazit_ID[i]);
    snprintf(actual_resp_string, 1000," %X",Fazit_ID[i]);
    strncat(string_actual,actual_resp_string,480);
  }
  BufferString[0]=0;
  snprintf(BufferString,1000,"%s",string_actual);
  TestExpectation(BufferString);
  
  for(i=0; i<16; i++)
  {
    data[i]=challenge[i];
  }
  
  for(i=0; i<16; i++)
  {
    data[i+16]=Verification_Hash_UsedDLC[i];
  }  
  
  for(i=0; i<23; i++)
  {
    data[i+32]=Fazit_ID[i];
  }  
  result = SecurityLocalGenerateHashMACSHA256(used_key, elCount(used_key), data, elCount(data), Identity_Hash_UsedDLC);

  actual_resp_string[0]=0;
  string_actual[0] =0;
}

void Get_IdentityHash_ResetDLC_test()
{
  byte used_key[32] = {0x66, 0x66, 0x66, 0xB5, 0x86, 0xCE, 0x68, 0xF7, 0xD4, 0x40, 0xF6, 0x3D, 0x6C, 0xFE, 0x24, 0x06, 0x78, 0xC8, 0xCF, 0x24, 0xF9, 0x4C, 0x35, 0x8C, 0x87, 0x5C, 0xAA, 0x1D, 0x3F, 0x75, 0xA3, 0x9A };
   
  byte data[55];
  byte challenge[16]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
  dword result = 255;
  int i;
  char actual_resp_string[1000]="";
  char string_actual[1000]="The Fazit ID is :";
  
  snprintf(BufferString, 100, "0x22 0xF1 0x7C");
  sendDiagnosticsRequest(BufferString , "Read FazitID");
  
  checkDiagnosticsResponse_returnArray(Fazit_ID , 26 , 1000);

  
  for(i=0; i<23; i++)
  {
    //write("Fazitid_after is %X",Fazit_ID[i]);
    snprintf(actual_resp_string, 1000," %X",Fazit_ID[i]);
    strncat(string_actual,actual_resp_string,480);
  }
  BufferString[0]=0;
  snprintf(BufferString,1000,"%s",string_actual);
  TestExpectation(BufferString);
  
  for(i=0; i<16; i++)
  {
    data[i]=challenge[i];
  }
  
  for(i=0; i<16; i++)
  {
    data[i+16]=Verification_Hash_ResetDLC[i];
  }  
  
  for(i=0; i<23; i++)
  {
    data[i+32]=Fazit_ID[i];
    //write("data is %X ",data[i+32]);
  }  
  result = SecurityLocalGenerateHashMACSHA256(used_key, elCount(used_key), data, elCount(data), Identity_Hash_ResetDLC);
  
  actual_resp_string[0]=0;
  string_actual[0] =0;
}

void Get_IdentityHash_ResetDLC()
{
   Get_IdentityHash_ResetDLC_test();
  
  Identity_Hash_ResetDLC_Expected[0] = 0x71;
  Identity_Hash_ResetDLC_Expected[1] = 0x03;
  Identity_Hash_ResetDLC_Expected[2] = 0xC0;
  Identity_Hash_ResetDLC_Expected[3] = 0x0C;
  Identity_Hash_ResetDLC_Expected[4] = 0x24;
  Identity_Hash_ResetDLC_Expected[5] = 0x00;
  
  for(k=0; k<16; k++)
  {
    Identity_Hash_ResetDLC_Expected[k+6] = Identity_Hash_ResetDLC[k];
  }
  testWaitForTimeout(100);

  sendDiagnosticsRequest_array(Identity_Hash_Request, 21); 
        
  testWaitForTimeout(100);

  snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0C");
  sendDiagnosticsRequest(BufferString , "Read Identity Hash for ResetDLC");
  
  checkDiagnosticsResponse_array(Identity_Hash_ResetDLC_Expected,22,1000, "Check positive response for Identity Hash"); 
}

void Get_ECU_TrainingCounter_UsedDLC()
{
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X", Vkms_TrainingCounter_DID[0],Vkms_TrainingCounter_DID[1]);
  sendDiagnosticsRequest(BufferString,"Read ECUTrainingCounter using SID22");
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X", Vkms_TrainingCounter_DID[0],Vkms_TrainingCounter_DID[1], ECU_Training_Counter_UsedDLC_Expected[0],ECU_Training_Counter_UsedDLC_Expected[1],ECU_Training_Counter_UsedDLC_Expected[2]);
  checkDiagnosticsResponse(BufferString,1000, "Check positive response for IO control diag request");
}

void Get_ECU_TrainingCounter_ResetDLC()
{
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X", Vkms_TrainingCounter_DID[0],Vkms_TrainingCounter_DID[1]);
  sendDiagnosticsRequest(BufferString,"Read ECUTrainingCounter using SID22");
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X", Vkms_TrainingCounter_DID[0],Vkms_TrainingCounter_DID[1], ECU_Training_Counter_ResetDLC_Expected[0],ECU_Training_Counter_ResetDLC_Expected[1],ECU_Training_Counter_ResetDLC_Expected[2]);
  checkDiagnosticsResponse(BufferString,1000, "Check positive response for ECU Training counter");
}

void Get_KeyList_ResetDLC()
{
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X", Vkms_KeyList_DID[0],Vkms_KeyList_DID[1]);
  sendDiagnosticsRequest(BufferString,"Read KeyList using SID22");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X", Vkms_KeyList_DID[0],Vkms_KeyList_DID[1],0x00,0x01,0x00,0x01,0x00,0x00);
  checkDiagnosticsResponse(BufferString , 1000 , "check if there is only one key in list");
}

void Get_MissingKeyList_ResetDLC()
{
  /* get missing key list */
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X", Vkms_MissingKeyList_DID[0],Vkms_MissingKeyList_DID[1]);
  sendDiagnosticsRequest(BufferString,"Read MissingKeyList using SID22");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X", Vkms_MissingKeyList_DID[0],Vkms_MissingKeyList_DID[1],0x00,0x04,0x00,0x01,0x01,0x83,0x03,0x2A,0x06,0xB3);
  checkDiagnosticsResponse(BufferString , 1000 , "check if there is only one key in list"); 
}

void Get_KeyList_UsedDLC()
{
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X", Vkms_KeyList_DID[0],Vkms_KeyList_DID[1]);
  sendDiagnosticsRequest(BufferString,"Read KeyList using SID22");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X", Vkms_KeyList_DID[0],Vkms_KeyList_DID[1],0x00,0x01,0x00,0x01);
  checkDiagnosticsResponse(BufferString , 1000 , "check if there is only one key in list");
}

void Get_MissingKeyList_UsedDLC()
{
  /* get missing key list */
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X", Vkms_MissingKeyList_DID[0],Vkms_MissingKeyList_DID[1]);
  sendDiagnosticsRequest(BufferString,"Read MissingKeyList using SID22");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X", Vkms_MissingKeyList_DID[0],Vkms_MissingKeyList_DID[1],0x00,0x01,0x00,0x01);
  checkDiagnosticsResponse(BufferString , 1000 , "check if there is only one key in list"); 
}

void DumpMemory_whole()
{
  long ret;
  
  char sciptpathhh[500]= "..\\Flashing_Scripts";
  
 
  /* stop */
  snprintf (BufferString, 1000, "test_stop.bat");
  ret = TestWaitForSyscall(sciptpathhh,BufferString, 0 ,600000);
  if (ret == -1)
  {
      write("Error executing command.");
  }
  else
  {
      write("Command executed successfully.");
  }
  
  testWaitForTimeout(timeout_5000_ms);
  
  /* dump */
  snprintf (BufferString, 1000, "ReadMemory.bat");
  ret = TestWaitForSyscall(sciptpathhh,BufferString, 0 ,600000);
  if (ret == -1)
  {
      write("Error executing command.");
  }
  else
  {
      write("Command executed successfully.");
  }
  
  testWaitForTimeout(timeout_5000_ms);
  
  /* run */
  snprintf (BufferString, 1000, "test_run.bat");
  ret = TestWaitForSyscall(sciptpathhh,BufferString, 0 ,600000);
  if (ret == -1)
  {
      write("Error executing command.");
  }
  else
  {
      write("Command executed successfully.");
  }
  
  testWaitForTimeout(timeout_5000_ms);
}

void Search_Memory_Whole()
{
  long ret;
  char buffer[64];
  char sciptpathhh[500]= "..\\Flashing_Scripts";
  
  snprintf (BufferString, 1000, "search_pattern.bat");
  ret = TestWaitForSyscall(sciptpathhh,BufferString, 0 ,600000);
  if (ret == -1)
  {
      write("Error executing command.");
  }
  else
  {
      write("Command executed successfully.");
  }
  
  testWaitForTimeout(timeout_2000_ms);
  
  glbHandle = openFileRead(file_path, 0);
  
  if ( glbHandle!=0 )
  {
    
    while ( fileGetString(buffer,elcount(buffer),glbHandle)!=0 ) {};
    counter_value = atol (buffer);
    write ("Last value %d.",counter_value);
    fileClose (glbHandle);
  }
  else
  {
    write ("File 'Data.Txt' was not opened for read access.");
  }
  
  if(counter_value == 0){
    
    testStepPass("There is no key in Memory");
  }
  else{
    testStepFail("There is a key in Memory");
  }
  
  fileRewind(glbHandle);
  
  testWaitForTimeout(timeout_2000_ms);
}

void Search_Memory_SRAM()
{
  long ret;
  char buffer[64];
  char sciptpathhh[500]= "..\\Flashing_Scripts";
  
  snprintf (BufferString, 1000, "search_IN_SRAM.bat");
  ret = TestWaitForSyscall(sciptpathhh,BufferString, 0 ,600000);
  if (ret == -1)
  {
      write("Error executing command.");
  }
  else
  {
      write("Command executed successfully.");
  }
  
  glbHandle = openFileRead(file_path, 0);
  
  if ( glbHandle!=0 )
  {
    
    while ( fileGetString(buffer,elcount(buffer),glbHandle)!=0 ) {};
    counter_value = atol (buffer);
    write ("Last value %d.",counter_value);
    fileClose (glbHandle);
  }
  else
  {
    write ("File 'Data.Txt' was not opened for read access.");
  }
  
  if(counter_value == 0){
    
    testStepPass("There is no key in Memory");
  }
  else{
    testStepFail("There is a key in Memory");
  }
  
  fileRewind(glbHandle);
}
testcase VKMS_TC_4()
{
  /********************** Precondition *************************/
  Flash_SW();
  /*testWaitForTimeout(timeout_10000_ms);
  
  Start_ExtendedSession();*/
  
  /******************** Action ***************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
    
  }
  testWaitForTimeout(timeout_2000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  reset_dlc1
  
  used_dlc1
  
  
  
  testWaitForTimeout(timeout_2000_ms);
  
  DumpMemory_whole();                         // 1111 and 2222
  
  testWaitForTimeout(timeout_2000_ms);
  
  Search_Memory_Whole();
  testWaitForTimeout(timeout_2000_ms);
  
  reset_dlc2
}

testcase VKMS_TC_5()
{
  /********************** Precondition *************************/
  Flash_SW();
  testWaitForTimeout(timeout_10000_ms);
  
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
   
  }
   testWaitForTimeout(timeout_2000_ms);
  /******************** Action ***************************/
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_2000_ms);
  
  Get_PssHash_UsedDLC();
  
  testWaitForTimeout(timeout_2000_ms);
  
  DumpMemory_whole();
  
  testWaitForTimeout(timeout_2000_ms);
  
  Search_Memory_SRAM();
  
  testWaitForTimeout(timeout_2000_ms);
}

testcase VKMS_TC_6()
{
  /********************** Precondition *************************/
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
    
  }
  testWaitForTimeout(timeout_2000_ms);
  /******************** Action ***************************/
  Download_UsedDLC(correct_gmac);
  testWaitForTimeout(timeout_2000_ms);
  
  /* get key */
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x03");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00 0x%02X",0x03);
  checkDiagnosticsResponse_returnValue(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x%02X",Key_status);
  checkDiagnosticsResponse_returnValue(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(timeout_2000_ms);
  
  DumpMemory_whole();
  
  testWaitForTimeout(timeout_2000_ms);
  
  Search_Memory_SRAM();
  
  testWaitForTimeout(timeout_2000_ms);
}

testcase VKMS_TC_40()
{
  /********************** Precondition *************************/
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
    
  }
  
  /******************** Action ***************************/
  testWaitForTimeout(timeout_2000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_2000_ms);
  
  /* sleep using turn off kl15*/
  sysSetVariableInt(sysvar::kl15,0);
  
  testWaitForTimeout(timeout_10000_ms);
  
  sysSetVariableInt(sysvar::kl15,1);
  
  testWaitForTimeout(timeout_10000_ms);
  
  Start_ExtendedSession();
  
  DumpMemory_whole();
  
  testWaitForTimeout(timeout_2000_ms);
  
  Search_Memory_SRAM();
  
  testWaitForTimeout(timeout_2000_ms);
}

testcase VKMS_TC_42()
{
  /********************** Precondition *************************/
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
    
  }
  testWaitForTimeout(timeout_2000_ms);
  
  /******************** Action ***************************/
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_2000_ms);
  
  Get_PssHash_UsedDLC();
  
  testWaitForTimeout(timeout_2000_ms);
  
  /* sleep using turn off kl15*/
  sysSetVariableInt(sysvar::kl15,0);
  
  testWaitForTimeout(timeout_10000_ms);
  
  sysSetVariableInt(sysvar::kl15,1);
  testWaitForTimeout(timeout_10000_ms);
  start_ExtendedSession();
  
  DumpMemory_whole(); 
  
  testWaitForTimeout(timeout_2000_ms);
  
  Search_Memory_SRAM();
  
  testWaitForTimeout(timeout_2000_ms);
}
testcase VKMS_TC_Preparations()
{
  /********************** Precondition *************************/
  long ret;
  char sciptpathhh[500]= "D:\\Brose\\dcu_validation\\CANoe_NM\\Flashing_Scripts";
  
  DiagInit();
  
  Flash_SW();
  
  Pause(20000,"wait time");
  Start_ExtendedSession();
  
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x01");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  
  Pause(4000,"wait time");
  Start_ExtendedSession();
  
  Download_ResetDLC();
  
  testWaitForTimeout(timeout_1000_ms);
  
  /* reset debugger */
  snprintf (BufferString, 1000, "test_reset.bat");
  ret = TestWaitForSyscall(sciptpathhh,BufferString, 0 ,600000);
  if (ret == -1)
  {
      write("Error executing command.");
  }
  else
  {
      write("Command executed successfully.");
  }
  
  testWaitForTimeout(timeout_1000_ms);
  
  /* run debugger */
  snprintf (BufferString, 1000, "test_run.bat");
  ret = TestWaitForSyscall(sciptpathhh,BufferString, 0 ,600000);
  if (ret == -1)
  {
      write("Error executing command.");
  }
  else
  {
      write("Command executed successfully.");
  }
  
  testWaitForTimeout(timeout_1000_ms);
  
  Start_ExtendedSession();
  
  if(Get_PssHash_ResetDLC() != 0){
    Download_UsedDLC(correct_gmac);
  }

}

testcase VKMS_TC_3()
{
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() != 0){
    Download_UsedDLC(correct_gmac);
    
  }
  testWaitForTimeout(timeout_2000_ms);
  
  //test_case_3 sub_test_0 type_id_1
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x03 0x00 0x00 0x01");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  //expected vkms key not supported return value "0x15"
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x15");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
}

/*A1: Import a DLC
A2: Call VKMS_getIdenityHash()*/
testcase VKMS_TC_20()
{
  /*************************** precondition ***********************/
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
    
  }
  
  
  /*********************** Action *******************************/ 
  testWaitForTimeout(timeout_2000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_2000_ms);
  
  Get_IdentityHash_UsedDLC();
  
  testWaitForTimeout(timeout_2000_ms);
}

testcase VKMS_TC_30()
{
  /*************************** precondition ***********************/
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
    
  }  
  testWaitForTimeout(timeout_2000_ms);
  /*********************** Action *******************************/ 
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_2000_ms);
  
  check_VIN_Number_UsedDLC();

  testWaitForTimeout(timeout_1000_ms);
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x30");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  testWaitForTimeout(timeout_1000_ms);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00");
  checkDiagnosticsResponse_returnValue(BufferString,1000, "Check positive response");
  
  //Pause(1000,"wait time");
  testWaitForTimeout(timeout_1000_ms);
  
  /*Read out the fault memory.*/
  sendDiagnosticsRequest("0x19 0x02 0x2F","Read DTCs wih mask 0x2F");
  checkDTCObtained_withMask(VKMS_new_download_container_required_due_to_vehicle_change_DTC,0x27, timeout_2000_ms, "check DTC is set with mask 0x2F");
  testWaitForTimeout(timeout_2000_ms);
  /* restart ECU */ 
  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x51 0x02");
  checkDiagnosticsResponse(BufferString,5000, "Check positive response");
  
  /* wait*/
  testWaitForTimeout(timeout_10000_ms);
  Start_ExtendedSession();

  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x30");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  //testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00");
  checkDiagnosticsResponse_returnValue(BufferString,1000, "Check positive response");
  
  //Pause(1000,"wait time");
  testWaitForTimeout(timeout_1000_ms);
  /*Read out the fault memory.*/
  sendDiagnosticsRequest("0x19 0x02 0x2F","Read DTCs wih mask 0x2F");
  checkDTCObtained_withMask(VKMS_new_download_container_required_due_to_vehicle_change_DTC,0x2F, timeout_1000_ms, "check DTC is set with mask 0x2F");
}

testcase VKMS_TC_32()
{
 
  /*************************** precondition ***********************/
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
    
  }
  
  
  /*********************** Action *******************************/ 
  testWaitForTimeout(timeout_2000_ms);
  
  Download_UsedDLC(correct_gmac);

  testWaitForTimeout(timeout_2000_ms);
  
  /* get verification hash :The Verification Hash matches the output of the DLC Tool */
  Get_VerificationHash_UsedDLC();
  
  testWaitForTimeout(timeout_2000_ms);
  
  /* get state */
  snprintf(BufferString, 100, "0x31 0x01 0xC0 0x0F 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0F");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0F 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X",0x24,0x00,MajorVersion,MinorVersion,BugFixVersion,0x05,0x05,0x05,0x00,0x06,0x9C,0x00);
  checkDiagnosticsResponse(BufferString,1000, "Check positive response for requestDownload_result");
  
  testWaitForTimeout(timeout_2000_ms);
  
  /* The ECU training counter matches the one provided in the DLC */
  Get_ECU_TrainingCounter_UsedDLC();
  
  testWaitForTimeout(timeout_2000_ms);
  
  /* The VKMS VIN matches the one provided in the DLC */
  check_VIN_Number_UsedDLC();
  
  testWaitForTimeout(timeout_2000_ms);
}

testcase VKMS_TC_34()
{
  /*************************** precondition ***********************/
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
 sendDiagnosticsRequest("0x14 0xFF 0xFF 0xFF","clear All DTC");
  
  checkDiagnosticsResponse("0x54",timeout_1000_ms,"check positive response for clear All DTCs");
  
  /* restart ECU */ 
  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  snprintf(BufferString, 100, "0x51 0x02");
  checkDiagnosticsResponse(BufferString,5000, "Check positive response");
  
  testWaitForTimeout(timeout_10000_ms);
  Start_ExtendedSession();
  /*********************** Action *******************************/ 
  /* import DLC */
  
  Download_UsedDLC_oneMissingKey();
  /* Vkms_application_requested_missing_key must be active */
  sendDiagnosticsRequest("0x19 0x02 0x2F","Read DTCs wih mask 0x2F");
  checkDTCObtained_withMask(Vkms_application_requested_missing_key_DTC,0x27, timeout_2000_ms, "check DTC is set with mask 0x2F");
}

testcase VKMS_TC_35()
{
  
   /*************************** precondition ***********************/ 
   Start_ExtendedSession();
 
  
   /************************** Action *****************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  testWaitForTimeout(timeout_2000_ms);
  
  /* Vkms_first_dlc_required must be active */
  sendDiagnosticsRequest("0x19 0x02 0x2F","Read DTCs wih mask 0x2F");
  checkDTCObtained_withMask(Vkms_first_dlc_required_DTC,0x2F, timeout_2000_ms, "check DTC is set with mask 0x2F");
  
}

testcase VKMS_TC_44()
{
  /*************************** precondition ***********************/ 
  Start_ExtendedSession();
 
  
  /************************** Action *****************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
   
  }
  
   testWaitForTimeout(timeout_2000_ms);
  
  /* check training counter equal 0 */
  Get_ECU_TrainingCounter_ResetDLC();
  
  testWaitForTimeout(timeout_2000_ms);
  
  /* check VIN number */
  check_VIN_Number_ResetDLC();
  
  testWaitForTimeout(timeout_2000_ms);
  
  /* Get pss Hash */
  Get_PssHash_ResetDLC();
  
  testWaitForTimeout(timeout_2000_ms);
  
  /* get identity hash result */
  Get_IdentityHash_ResetDLC();
  
  testWaitForTimeout(timeout_2000_ms);
  
  /* get key list */
  /* Only 1 key (the PSS) is found in this list.*/
  Get_KeyList_ResetDLC();
  
  testWaitForTimeout(timeout_2000_ms);
  
  /* get missing key list */
  Get_MissingKeyList_ResetDLC();
  
  testWaitForTimeout(timeout_2000_ms);
  
    /* restart ECU */ 
  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  snprintf(BufferString, 100, "0x51 0x02");
  checkDiagnosticsResponse(BufferString,5000, "Check positive response");
  Start_ExtendedSession();

  /* VKMS_FIRST_DOWNLOAD_CONTAINER_REQUIRED must be active */
  sendDiagnosticsRequest("0x19 0x02 0x2F","Read DTCs wih mask 0x2F");
  checkDTCObtained_withMask(VKMS_FIRST_DOWNLOAD_CONTAINER_REQUIRED_DTC,0x2F, 1000, "check DTC is set with mask 0x2F");
   
  /*Correct Verification Hash */
  Get_VerificationHash_ResetDLC();
  
  testWaitForTimeout(timeout_2000_ms);
}

testcase VKMS_TC_45()
{
   /*************************** precondition ***********************/ 
   Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
    
  }
   
  testWaitForTimeout(timeout_2000_ms);
  /************************** Action *****************************/
  
  Download_UsedDLC(correct_gmac);
  testWaitForTimeout(timeout_2000_ms);
  
  /* get state */
  snprintf(BufferString, 100, "0x31 0x01 0xC0 0x0F 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0F");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response for requestDownload_result");
  
  testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0F");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0F 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X",0x24,0x00,MajorVersion,MinorVersion,BugFixVersion,0x05,0x05,0x05,0x00,0x06,0x9C,0x00);
  checkDiagnosticsResponse(BufferString,1000, "Check positive response for requestDownload_result");
  
}

testcase VKMS_TC_7()
{
   /*************************** precondition ***********************/ 
   int error_value;
   error_value = VKMS_ERR_BUSY;
   Start_ExtendedSession();
   if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
   
  
    time1 = timeNow() / 100000.0; 

    Download_UsedDLC(correct_gmac);
  
    time2 = timeNow() / 100000.0;
   
    if((time2 - time1) < 6 ){
      write("time = %f",time2 - time1);
      snprintf(BufferString,1000,"correct result and the time is less than 6 and equal to %f s",time2 - time1);
      testStepPass(BufferString);
    }
    else if((time2 - time1) > 6){
      write("time = %f",time2 - time1);
      testStepFail("time exceeded 6 seconds");
    }
}

testcase VKMS_TC_8()
{
  /*************************** precondition ***********************/ 
  int error_value;
  error_value = VKMS_ERR_BUSY;
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  for(j=0; j<100; j++)
  {
     time1 = timeNow() / 100000.0;
    
    /* Download used dlc */
     Download_UsedDLC(correct_gmac);
    
    time2 = timeNow() / 100000.0;
   
    time = time + (time2 - time1);
    
    if((time2-time1) < MinTime_useddlc){
      MinTime_useddlc = time2-time1;
    }
     if((time2-time1) > MaxTime_useddlc){
      MaxTime_useddlc = time2-time1;
    }
    
    testWaitForTimeout(timeout_1000_ms);
    
    Download_ResetDLC();
    
    if(j == 99)
    {
      write("time is %f s",time/100);
      write("MinTime is %f s",MinTime_useddlc);
      write("MaxTime is %f s",MaxTime_useddlc);
      
      if(MaxTime_useddlc < 6)
      {
          snprintf(BufferString,1000,"MaxTime_useddlc:%f s\n MinTime_useddlc:%f s\n AverageTime:%f s",MaxTime_useddlc,MinTime_useddlc,time/100);
          testStepPass(BufferString);
      }
      else
      {
          snprintf(BufferString,1000,"MaxTime_useddlc:%f s\n MinTime_useddlc:%f s\n AverageTime:%f s",MaxTime_useddlc,MinTime_useddlc,time/100);
          testStepFail(BufferString);
      }
    }
    testWaitForTimeout(timeout_1000_ms);
  }
  
  MinTime_useddlc = 6000;
  MaxTime_useddlc = 0;
  time = 0;
}



testcase VKMS_TC_9()               //need DID
{
  
  /*************************** precondition ***********************/ 
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() != 0){
    Download_UsedDLC(correct_gmac);
  }  
  
  testWaitForTimeout(timeout_2000_ms);
  
  /************************** Action ****************************/
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x09 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(timeout_2000_ms);
  
   snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  //expected csm return not ok return value "0x01"
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x01");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(timeout_2000_ms);
  
    /* restart ECU */ 
  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x51 0x02");
  checkDiagnosticsResponse(BufferString,5000, "Check positive response");
  
  testWaitForTimeout(STARTUP_TIME);
}

testcase VKMS_TC_10()               //need DID
{
  
  /*************************** precondition ***********************/ 
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() != 0){
    Download_UsedDLC(correct_gmac);
  }  
  testWaitForTimeout(timeout_2000_ms);
  /************************** Action ****************************/
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x10 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(timeout_2000_ms);
  
   snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  //expected csm return not ok for two keys with return value "0x01"
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x01 0x01");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(timeout_2000_ms);
  /* restart ECU */ 
  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x51 0x02");
  checkDiagnosticsResponse(BufferString,5000, "Check positive response");
  
  testWaitForTimeout(STARTUP_TIME);
}

void Flash_SW()
{
  
  long ret;
  
  char sciptpathhh[500]= "..\\Flashing_Scripts";
  char abspath[500];
  
  /* open winidea */
  
  getAbsFilePath("Flashing_Scripts\\test.bat", abspath , 500);
  write ("absPath: %s ", abspath);
  /* Download Code */
  //snprintf (BufferString, 1000, "test.bat");
  ret = TestWaitForSyscall(abspath, 0 ,600000);
  if (ret == -1)
  {
      write("Error executing command.");
  }
  else
  {
      write("Command executed successfully.");
  }
  
  //testWaitForTimeout(timeout_5000_ms);
  
  /* Run debugger */
  getAbsFilePath("Flashing_Scripts\\test2.bat", abspath , 500);
  write ("absPath: %s ", abspath);
  //snprintf (BufferString, 1000, "test_run.bat");
  ret = TestWaitForSyscall(abspath, 0 ,600000);
  if (ret == -1)
  {
      write("Error executing command.");
  }
  else
  {
      write("Command executed successfully.");
  }
  
  testWaitForTimeout(timeout_5000_ms);
}

void power_reset()
{
  
  long ret;
  char sciptpathhh[500]= "..\\Flashing_Scripts";
  
  snprintf (BufferString, 1000, "Power_Reset.bat");
  ret = TestWaitForSyscall(sciptpathhh,BufferString, 0 ,600000);
  if (ret == -1)
  {
      write("Error executing command.");
  }
  else
  {
      write("Command executed successfully.");
  }
}

/*A1: Use key with a key-ID which is meant to be used for a specific application.
Check that keys are operational using SecOC frames*/
testcase VKMS_TC_11()
{
  /*************************** precondition ***********************/ 
  int value;
  
  Flash_SW();
  
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  
  /************************** Action *****************************/
  testWaitForTimeout(timeout_2000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  sendDiagnosticsRequest("0x14 0xFF 0xFF 0xFF","clear All DTC");
  
  checkDiagnosticsResponse("0x54",timeout_1000_ms,"check positive response for clear All DTCs");
  Pause(5000 , "wait for Clear DTCs");
  
  value = sysGetVariableInt(sysvar::product);
  
  if(value == Audi)
  {
    sendDiagnosticsRequest("0x19 0x02 0x2F","Read All DTC with mask 2F");
    checkDTCObtained_withMask_2(SOK_TimeServer , 0x2F , timeout_2000_ms , "check DTC SOK_TimeServer logged with Mask 2F");
    sendDiagnosticsRequest("0x19 0x02 0x2F","Read All DTC with mask 2F");
    checkDTCObtained_withMask_2(SOK_Signature , 0x2F , timeout_2000_ms , "check DTC SOK_Signature logged with Mask 2F");
  }
}

testcase VKMS_TC_15()
{
  int value;
  /*************************** precondition ***********************/ 
  Flash_SW();
  
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  testWaitForTimeout(timeout_2000_ms);
  
  /************************** Action *****************************/
  Download_UsedDLC_oneChangedKey();
  
  testWaitForTimeout(timeout_2000_ms);
  
  /* restart ECU */ 
  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x51 0x02");
  checkDiagnosticsResponse(BufferString,5000, "Check positive response");
  
  testWaitForTimeout(STARTUP_TIME);
  
  Start_ExtendedSession();
  
  sendDiagnosticsRequest("0x14 0xFF 0xFF 0xFF","clear All DTC");
  
  checkDiagnosticsResponse("0x54",timeout_1000_ms,"check positive response for clear All DTCs");
  Pause(5000 , "wait for Clear DTCs");
  
   value = sysGetVariableInt(sysvar::product);
  
  if(value == Audi)
  {
    sendDiagnosticsRequest("0x19 0x02 0x2F","Read All DTC with mask 2F");
    checkDTCObtained_withMask_2(SOK_TimeServer , 0x2F , timeout_2000_ms , "check DTC SOK_TimeServer logged with Mask 2F");
    sendDiagnosticsRequest("0x19 0x02 0x2F","Read All DTC with mask 2F");
    checkDTCObtained_withMask_2(SOK_Signature , 0x2F , timeout_2000_ms , "check DTC SOK_Signature logged with Mask 2F");
  }
}


testcase VKMS_TC_19()
{
  /*************************** precondition ***********************/ 
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  testWaitForTimeout(timeout_2000_ms);
  /************************** Action *****************************/
  Download_UsedDLC(wrong_gmac);
  
  testWaitForTimeout(timeout_2000_ms);
  
}

testcase VKMS_TC_21()
{
   /*************************** precondition ***********************/ 
  Start_ExtendedSession();
   if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
   testWaitForTimeout(timeout_2000_ms);
  
  /************************** Action *****************************/
  Download_UsedDLC(correct_gmac);
  
   testWaitForTimeout(timeout_2000_ms);
  
  /* get metadata for key with type ID 0x0183*/
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x21 0x00 0x01 0x83");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
   testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  //meta data of key 0x183 according to downloaded DLC should be 00 "OK" followed by training counter 00 01 followed by flags 00 followed by genus 11
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00 0x01 0x00 0x00 0x11");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
   testWaitForTimeout(timeout_2000_ms);
  
    /* get metadata for key with type ID 0x0001*/
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x21 0x00 0x00 0x01");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
   testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  //meta data of key 0x0001 according to downloaded DLC should be 00 "OK" followed by training counter 00 01 followed by flags 00 followed by genus 11
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00 0x03 0x00 0x00 0x12");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
   testWaitForTimeout(timeout_2000_ms);
    /* get metadata for key with type ID 0x032A*/
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x21 0x00 0x03 0x2A");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
   testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  //meta data of key 0x32A according to downloaded DLC should be 00 "OK" followed by training counter 00 01 followed by flags 00 followed by genus 11
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00 0x01 0x00 0x00 0x11");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
   testWaitForTimeout(timeout_2000_ms);
      /* get metadata for key with type ID 0x06B3*/
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x21 0x00 0x06 0xB3");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
   testWaitForTimeout(timeout_2000_ms);
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  //meta data of key 0x6B3 according to downloaded DLC should be 00 "OK" followed by training counter 00 01 followed by flags 00 followed by genus 11
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00 0x01 0x00 0x00 0x11");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
   testWaitForTimeout(timeout_2000_ms);
}

testcase VKMS_TC_22()
{
  int value;
  /*************************** precondition ***********************/ 
  Start_ExtendedSession();
   if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  /************************** Action *****************************/
  testWaitForTimeout(timeout_2000_ms);
  
  Download_UsedDLC_oneChangedKey();
  
  testWaitForTimeout(timeout_2000_ms);
  
  /*detach the power supply and reattach it afterwards*/
  //testWaitForTesterConfirmation("detach the power supply and reattach it afterwards");
  
  power_reset();
  
  testWaitForTimeout(STARTUP_TIME);
  
  Start_ExtendedSession();
  
  sendDiagnosticsRequest("0x14 0xFF 0xFF 0xFF","clear All DTC");
  
  checkDiagnosticsResponse("0x54",timeout_1000_ms,"check positive response for clear All DTCs");
  Pause(5000 , "wait for Clear DTCs");
  
  
  value = sysGetVariableInt(sysvar::product);
  
  if(value == Audi)
  {
    sendDiagnosticsRequest("0x19 0x02 0x2F","Read All DTC with mask 2F");
    checkDTCObtained_withMask_2(SOK_TimeServer , 0x2F , timeout_2000_ms , "check DTC SOK_TimeServer logged with Mask 2F");
    sendDiagnosticsRequest("0x19 0x02 0x2F","Read All DTC with mask 2F");
    checkDTCObtained_withMask_2(SOK_Signature , 0x2F , timeout_2000_ms , "check DTC SOK_Signature logged with Mask 2F");
  }
  
}
/*A1: Import initial Key (IS) //done in TC_1 and order is preserved
A2: Reuse the same interface to insert a different key.*/
testcase VKMS_TC_31()
{
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x31 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x18");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  if(Get_PssHash_ResetDLC() == 0){
    testStepFail("PSS hash is changed unexpectedly");
  }

}

testcase VKMS_TC_33()
{
  /*************************** precondition ***********************/ 
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  testWaitForTimeout(2000);
  /************************** Action *****************************/
  Download_UsedDLC(correct_gmac);
    testWaitForTimeout(2000);

  /* restart ECU */ 
  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x51 0x02");
  checkDiagnosticsResponse(BufferString,5000, "Check positive response");
  
  testWaitForTimeout(STARTUP_TIME);
  
  Start_ExtendedSession();
  
/* get metadata for key with type ID 0x0183*/
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x21 0x00 0x01 0x83");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(2000);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  //meta data of key 0x183 according to downloaded DLC should be 00 "OK" followed by training counter 00 01 followed by flags 00 followed by genus 11
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00 0x01 0x00 0x00 0x11");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(2000);
  
    /* get metadata for key with type ID 0x0001*/
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x21 0x00 0x00 0x01");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(2000);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  //meta data of key 0x0001 according to downloaded DLC should be 00 "OK" followed by training counter 00 01 followed by flags 00 followed by genus 11
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00 0x03 0x00 0x00 0x12");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(2000);
  
    /* get metadata for key with type ID 0x032A*/
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x21 0x00 0x03 0x2A");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(2000);
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  //meta data of key 0x32A according to downloaded DLC should be 00 "OK" followed by training counter 00 01 followed by flags 00 followed by genus 11
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00 0x01 0x00 0x00 0x11");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(2000);
      /* get metadata for key with type ID 0x06B3*/
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x21 0x00 0x06 0xB3");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(2000);
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  //meta data of key 0x6B3 according to downloaded DLC should be 00 "OK" followed by training counter 00 01 followed by flags 00 followed by genus 11
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00 0x01 0x00 0x00 0x11");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(2000);
}


testcase VKMS_TC_41()
{
  /*************************** precondition ***********************/ 
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
    
  }
  
  /************************** Action *****************************/ 
  testWaitForTimeout(timeout_2000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_2000_ms);
  
  Get_VerificationHash_UsedDLC();
  
  /* sleep using turn off kl15*/
  sysSetVariableInt(sysvar::kl15,0);
  if(sysGetVariableInt(sysvar::kl15) == 0)
  {
    testStepPass("ECU sleep");
  }
  
  testWaitForTimeout(timeout_10000_ms);

  sysSetVariableInt(sysvar::kl15,1);
  
  if(sysGetVariableInt(sysvar::kl15) == 1)
  {
    testStepPass("ECU wakeup");
  }
  testWaitForTimeout(timeout_10000_ms);
  start_ExtendedSession();
  
  Get_VerificationHash_UsedDLC();
  
  testWaitForTimeout(timeout_2000_ms);
  
}


testcase VKMS_TC_43()
{
  /*************************** precondition ***********************/ 
  Start_ExtendedSession();
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  testWaitForTimeout(timeout_2000_ms);
  
  /************************** Action *****************************/ 
  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x43 0x01");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  Pause(1000,"wait time");
  Download_UsedDLC_oneChangedKey();
  Pause(1000,"wait time");

  snprintf(BufferString, 100, "0x2E 0xEE 0x00 0x43 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x6E 0xEE 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(timeout_2000_ms);
  
  snprintf(BufferString, 100, "0x22 0xEE 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x62 0xEE 0x00 0x00");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response");
  
  testWaitForTimeout(timeout_2000_ms);
}

