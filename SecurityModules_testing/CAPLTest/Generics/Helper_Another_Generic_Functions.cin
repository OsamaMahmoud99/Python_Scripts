/*@!Encoding:1252*/
/*@!Encoding:1252*/
/*@!Encoding:1252*/
includes{
  
  #include "..\Helpers\Helper_Config.cin"
  #include "..\Helpers\Helper_Generic_Functions.cin"
  #include "..\Helpers\Helper_TOELLNER.cin"
  #include "..\Helpers\Helper_CAN_Functions.cin"
  #include "..\Helpers\Helper_CyberSecurity.cin"
  #include "..\Helpers\Helper_Diag.cin"
  #include "..\Helpers\Helper_TestCreator.cin"
  #include "..\Helpers\Helper_TestSupport.cin"
  
 
  
}

variables{
  
  diagRequest SWSP174.HardReset  HR_req;
  
   diagRequest SWSP174.Authentication_Deauthenticate req_To_Deauthenticate;
  diagRequest SWSP174.FaultMem_ReportDTCByStatusMask req_To_get_DTCs;
  diagResponse SWSP174.FaultMem_ReportDTCByStatusMask resp_To_get_DTCs;
  diagRequest SWSP174_Int.FaultMem_ReportDTCByStatusMask req_To_get_DTCs_OffBoard;
  diagResponse SWSP174_Int.FaultMem_ReportDTCByStatusMask resp_To_get_DTCs_OffBoard;
  diagRequest SWSP174.FaultMem_ClearGroup req_DTCs_reset;
 diagRequest SWSP174.Extended_Start req_To_Extended_start;
  diagRequest SWSP174.Default_Start req_To_default_start;
  diagRequest SWSP174.ActiveDiagnosticInformation_Read req_To_get_current_session;
  diagResponse SWSP174.ActiveDiagnosticInformation_Read resp_To_get_current_session;  

      diagRequest SWSP174.Request_Seed_Reprogramming seedReq;
    diagRequest SWSP174.Send_Key_Reprogramming keyReq;
    diagResponse SWSP174.Send_Key_Reprogramming keyResponse;
  
      diagRequest SWSP174.ActiveDiagnosticInformation_Read ActiveDiagnosticInformation_Read_Req;
      diagRequest SWSP174.EnableRxAndDisableTx_Control EnableRxAndDisableTx_Control_Req;
  
  diagRequest SWSP174.Check_memory_Start  Check_memory_Routine_req;
    diagResponse SWSP174.Check_memory_Start  Check_memory_Routine_response;
  
    diagRequest SWSP174.CheckProgrammingDependencies_Start CheckProgrammingDependencies_req;
    diagResponse SWSP174.CheckProgrammingDependencies_Start CheckProgrammingDependencies_response;
  
    diagRequest SWSP174.Erase_Memory_Start Erase_Memory_req;
    diagResponse SWSP174.Erase_Memory_Start  Erase_Memory_response;

  long KeYGenStatus;
    
   
   
  diagRequest SWSP174.DTC_Setting_Mode_On_Control req_DTC_Logging_ON;
  diagRequest SWSP174.DTC_Setting_Mode_Off_Control req_DTC_Logging_OFF;
  
  diagRequest SWSP174.SoftReset req_To_ECU_soft_reset;
  diagRequest SWSP174.HardReset req_To_ECU_hard_reset;
  
  diagRequest SWSP174.RequestDownload req_To_Download;
    diagResponse SWSP174.RequestDownload response_To_Download;
  
  diagRequest SWSP174.TransferData req_To_TransferData;
  diagResponse SWSP174.TransferData response_To_TransferData;
  
  diagRequest SWSP174.RequestTransferExit req_To_EXIT_TransferData;
    diagResponse SWSP174.RequestTransferExit response_To_EXIT_TransferData;
  
    diagRequest SWSP174.BlockInitiate_Start req_BlockInitiate_Start;
    diagResponse SWSP174.BlockInitiate_Start response_BlockInitiate_Start;  
 
  
    diagRequest SWSP174.UpdateCleanup_Start req_UpdateCleanup_Start;
    diagResponse SWSP174.UpdateCleanup_Start response_UpdateCleanup_Start;
  
      diagRequest SWSP174.UpdateCleanup_RequestResults req_UpdateCleanup_RequestResults;
    diagResponse SWSP174.UpdateCleanup_RequestResults response_UpdateCleanup_RequestResults;
  
    diagRequest SWSP174.BlockInstall_RequestResults req_BlockInstall_RequestResults;
    diagResponse SWSP174.BlockInstall_RequestResults response_BlockInstall_RequestResults;
  
          diagRequest SWSP174.ActivateSoftware_Start req_ActivateSoftware_Start;
    diagResponse SWSP174.ActivateSoftware_Start response_ActivateSoftware_Start;
  
      diagRequest SWSP174.ActivateSoftware_RequestResults req_ActivateSoftware_RequestResults;
    diagResponse SWSP174.ActivateSoftware_RequestResults response_ActivateSoftware_RequestResults;
  


  dword NormDTC =  0;
  dword NoDTC =  1;
  dword NoIgnDTC=2;
  dword PN14_NormDTC =  3;
  
  dword HighDTC =  0xA10E00;
  dword LowDTC = 0xA10D00;

  dword PN14_HighDTC =  0xA10B00;
  dword PN14_LowDTC = 0xA10A00;
  
    dword IgnDTC = 0xC16887;


  
  byte default_session=0x01;
  byte extented_session=0x03;
  PDU STEERING_WHEEL::DIAG_SWCM_0E_ExtEth_RQ_FD_ST3 PhysicalExtReq;
  
  PDU STEERING_WHEEL::DIAG_SWCM_0E_IntEth_RQ_FD_ST3 PhysicalIntReq;
  PDU STEERING_WHEEL::DIAG_RQ_GLOBAL_ExtEth_FD_ST3 FunctionalExtReq;
  PDU STEERING_WHEEL::DIAG_RQ_GLOBAL_IntEth_FD_ST3 FunctionalIntReq;
  
  dword glbHandle_result ;
   dword glbHandle_complete ;
  dword glbHandle_version;
  msTimer T1;
  msTimer T2;
 
}
on timer T1{
   char readStringFromFile[200]=0;
  long Res;
  
         write("%c",readStringFromFile[0]);
    glbHandle_complete = OpenFileRead ("D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\examples\\can_lin_eth\\fbl_can\\vFlash\\Varibles\\complete.txt", 0);
      fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_complete);
    fileClose (glbHandle_complete);

  if(readStringFromFile[0] =='1'){
    
      Res = TestSupplyTextEvent("Flashing Done");

  }else{
    
    setTimer(T1,100);
  }

}

on timer T2{
   char readStringFromFile[200]=0;
  long Res;
  
         write("%c",readStringFromFile[0]);
    glbHandle_complete = OpenFileRead ("D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\Genration_complete.txt", 0);
      fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_complete);
    fileClose (glbHandle_complete);

  if(readStringFromFile[0] =='1'){
    
      Res = TestSupplyTextEvent("Flash Prepration Done");

  }else{
    
    setTimer(T2,100);
  }

}




 void Get_Versions(char SW_version[],char FBL_version[],char HSM_version[]){
  int ret1;
  char str[200];
    char str2[200];
    char str3[200];
long EventHandle1, lReturn;
  char readStringFromFile[200]=0;
  SW_version[0]='\0';
  FBL_version[0]='\0';
  HSM_version[0]='\0';
  
  testStep("Step","Geting Versions");
  
  TestAction("Geting Versions");
 
  
 
  glbHandle_version = OpenFileRead ("D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\Build_Files\\APP_version.hex", 0);
     fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_version);
    fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_version);
    fileClose (glbHandle_version);
  
  snprintf(SW_version,elCount(SW_version),"0x%c%c 0x%c%c 0x%c%c",readStringFromFile[9],readStringFromFile[10],readStringFromFile[11],readStringFromFile[12],readStringFromFile[13],readStringFromFile[14]);

   
        snprintf(str,elCount(str),"Read SW_version %s",SW_version);
        testStepPass(str);
        AssertPass(str);
    write(str);
  
  
    glbHandle_version = OpenFileRead ("D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\Build_Files\\FBL_version.hex", 0);
     fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_version);
    fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_version);
    fileClose (glbHandle_version);
  
  snprintf(FBL_version,elCount(FBL_version),"0x%c%c 0x%c%c 0x%c%c",readStringFromFile[9],readStringFromFile[10],readStringFromFile[11],readStringFromFile[12],readStringFromFile[13],readStringFromFile[14]);

   

  
  
  
          snprintf(str2,elCount(str2),"Read FBL_version %s",FBL_version);
        testStepPass(str2);
        AssertPass(str2);
    write(str2);
  
      glbHandle_version = OpenFileRead ("D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\Build_Files\\HSM_version.hex", 0);
     fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_version);
    fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_version);
    fileClose (glbHandle_version);
  
  snprintf(HSM_version,elCount(HSM_version),"0x%c%c 0x%c%c 0x%c%c",readStringFromFile[9],readStringFromFile[10],readStringFromFile[11],readStringFromFile[12],readStringFromFile[13],readStringFromFile[14]);

   
   
 
  
          snprintf(str3,elCount(str3),"Read HSM_version %s",HSM_version);
        testStepPass(str3);
        AssertPass(str3);
    write(str3);
      
    testStep("Step","Geting Versions Done");
  
}

 void flash_Prepration(void){
  int ret1;
  char str[200];
    char str2[200];
    char str3[200];
long EventHandle1, lReturn;
 char readStringFromFile[200]=0;

  
  testStep("Step","Starting Flash Prepration");
  
  TestAction("Starting Flash Prepration");
 
  
  ret1= sysExec("D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\Flash_automation.bat", "","D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash"); 
    
  testWait(100);

   TestExpectation("Expected: Starting Flash Prepration : Sucuess");

  
  if(ret1==1){
     
    
        testWaitForTimeout(5000);

        TestAction("Checking for finshing Flash Prepration every 100 ms"); 
        
    EventHandle1 = TestJoinTextEvent("Flash Prepration Done");
    setTimer(T2,100);
    lReturn = TestWaitForAnyJoinedEvent (300000);
        
  

    if (lReturn > 0)
  {
    if (lReturn == EventHandle1)
    {    
        testStepPass("Result: Starting Flash Prepration : Sucuess");
        AssertFail("Result: Starting Flash Prepration : Sucuess");
    }

  }else{
            write("TestWaitForAnyJoinedEvent lReturn:  %d",lReturn);
                testStepFail("Result: Starting Flash Prepration : Failed ");
        AssertFail("Result: Starting Flash Prepration : Failed");
            return;
    
  }

    

  }else{
    
            testStepFail("Failed to start Flash Prepration");
        AssertFail("Failed to start Flash Prepration");
  }
    testStep("Step","Flash Prepration Done");
  
}



 void flash_start(char batch_path[]){
  int ret1;
  char str[200];
    char str2[200];
    char str3[200];
 char readStringFromFile[200]=0;
  long timeout=0;
  
  testStep("Step","Starting Flashing");
  
  snprintf(str,elcount(str),"Flashing %s",batch_path);
  TestAction(str);
 

  
  ret1= sysExec(batch_path, "","D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\examples\\can_lin_eth\\fbl_can\\vFlash"); 
  

  if(ret1==1){
     
            testStepPass("Success to start Flashing");
        AssertPass("Success to start Flashing");
  }else{
    
            testStepFail("Failed to start Flashing");
        AssertFail("Failed to start Flashing");
  }
    
  
}



 void flash_Check(int expected_result){
  int ret1;
  char str[200];
    char str2[200];
    char str3[200];
 char readStringFromFile[200]=0;
long EventHandle1, lReturn;

 if(expected_result ==2){
   snprintf(str2,elcount(str2),"Check Flashing expected_result %d : Don't Care",expected_result);
   TestExpectation(str2);
  }
  else if(expected_result ==1){
   snprintf(str2,elcount(str2),"Check Flashing expected_result %d : Sucess",expected_result);
   TestExpectation(str2);
  }else{
       snprintf(str2,elcount(str2),"Check Flashing expected_result %d : Failed",expected_result);
   TestExpectation(str2);
  }
 


     
    
  TestAction("Checking for finshing Flashing every 100 ms"); 
        
    EventHandle1 = TestJoinTextEvent("Flashing Done");
    setTimer(T1,100);
    lReturn = TestWaitForAnyJoinedEvent (300000);
        
  

    if (lReturn > 0)
  {
    if (lReturn == EventHandle1)
    {
      glbHandle_complete = OpenFileRead ("D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\examples\\can_lin_eth\\fbl_can\\vFlash\\Varibles\\complete.txt", 0);
      fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_complete);
    fileClose (glbHandle_complete);
      
    write("Flashing is done :%c",readStringFromFile[0]);
    
  //  testWait(5000);
    
     glbHandle_result = OpenFileRead ("D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\examples\\can_lin_eth\\fbl_can\\vFlash\\Varibles\\result.txt", 0);
     fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_result);
    fileClose (glbHandle_result);
        if (expected_result==2){
                snprintf(str3,elCount(str3),"Expected:Don't Care Flashing and Actual %s",readStringFromFile);
        testStepPass(str3);
        AssertPass(str3);
        }
    else if (expected_result==1){
    if(   readStringFromFile[0] == '0'){
      
                         testStepPass("Expected=Actual:Success Flashing");
                  AssertPass("Expected=Actual:Success Flashing");
      
    }else{
      snprintf(str3,elCount(str3),"Expected Success flashing ,but Failed Flashing Result: %s",readStringFromFile);
        testStepFail(str3);
        AssertFail(str3);
    }
    }else{
      
          if(   readStringFromFile[0] == '0'){
        testStepFail("Expected failed Flashing , but success Flashing ");
        AssertFail("Expected failed Flashing , but success Flashing ");
            
            
    }else{
        snprintf(str3,elCount(str3),"Expected=Actual:Failed Flashing %s",readStringFromFile);
        testStepPass(str3);
        AssertPass(str3);
      
      
    }
      
    }
    }

  }else{
            write("TestWaitForAnyJoinedEvent lReturn:  %d",lReturn);
                testStepFail("Flashing TimeOut: Someone Closed CMD while running ");
        AssertFail("Flashing TimeOut: Someone Closed CMD while running ");
            return;
    
  }

    
    testStep("Step","Flashing Done");
  
}


 void flash(char batch_path[],int expected_result){
  int ret1;
  char str[200];
    char str2[200];
    char str3[200];
long EventHandle1, lReturn;
 char readStringFromFile[200]=0;

  
  testStep("Step","Starting Flashing");
  
  snprintf(str,elcount(str),"Flashing %s",batch_path);
  TestAction(str);
 
  
  ret1= sysExec(batch_path, "","D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\examples\\can_lin_eth\\fbl_can\\vFlash"); 
    
  testWait(100);
   if(expected_result ==2){
   snprintf(str2,elcount(str2),"Check Flashing expected_result %d : Don't Care",expected_result);
   TestExpectation(str2);
  }
  else if(expected_result ==1){
   snprintf(str2,elcount(str2),"Check Flashing expected_result %d : Sucess",expected_result);
   TestExpectation(str2);
  }else{
       snprintf(str2,elcount(str2),"Check Flashing expected_result %d : Failed",expected_result);
   TestExpectation(str2);
  }
  
  if(ret1==1){
     
    
        testWaitForTimeout(5000);

        TestAction("Checking for finshing Flashing every 100 ms"); 
        
    EventHandle1 = TestJoinTextEvent("Flashing Done");
    setTimer(T1,100);
    lReturn = TestWaitForAnyJoinedEvent (300000);
        
  

    if (lReturn > 0)
  {
    if (lReturn == EventHandle1)
    {    
      glbHandle_complete = OpenFileRead ("D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\examples\\can_lin_eth\\fbl_can\\vFlash\\Varibles\\complete.txt", 0);
      fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_complete);
    fileClose (glbHandle_complete);
      
    write("Flashing is done :%c",readStringFromFile[0]);
    
  //  testWait(5000);
    
     glbHandle_result = OpenFileRead ("D:\\Jenkins\\workspace\\Benz_vx5_src\\3_Tests\\Tools\\proj5652_app_mbag_v5x_val_tools\\Vflash\\examples\\can_lin_eth\\fbl_can\\vFlash\\Varibles\\result.txt", 0);
     fileGetString(readStringFromFile, elcount(readStringFromFile), glbHandle_result);
    fileClose (glbHandle_result);
        if (expected_result==2){
                snprintf(str3,elCount(str3),"Expected:Don't Care Flashing and Actual %s",readStringFromFile);
        testStepPass(str3);
        AssertPass(str3);
        }
    else if (expected_result==1){
    if(   readStringFromFile[0] == '0'){
      
                         testStepPass("Expected=Actual:Success Flashing");
                  AssertPass("Expected=Actual:Success Flashing");
      
    }else{
      snprintf(str3,elCount(str3),"Expected Success flashing ,but Failed Flashing Result: %s",readStringFromFile);
        testStepFail(str3);
        AssertFail(str3);
    }
    }else{
      
          if(   readStringFromFile[0] == '0'){
        testStepFail("Expected failed Flashing , but success Flashing ");
        AssertFail("Expected failed Flashing , but success Flashing ");
            
            
    }else{
        snprintf(str3,elCount(str3),"Expected=Actual:Failed Flashing %s",readStringFromFile);
        testStepPass(str3);
        AssertPass(str3);
      
      
    }
      
    }
    }

  }else{
            write("TestWaitForAnyJoinedEvent lReturn:  %d",lReturn);
                testStepFail("Flashing TimeOut: Someone Closed CMD while running ");
        AssertFail("Flashing TimeOut: Someone Closed CMD while running ");
            return;
    
  }

    
    
    

  }else{
    
            testStepFail("Failed to start Flashing");
        AssertFail("Failed to start Flashing");
  }
    testStep("Step","Flashing Done");
  
}





void wait_until_Diag_response(diagRequest * Request, dword timeout){
  int ret;
 


  TestAction("wait until Response of Given Request");
 
  
  ret=testWaitForDiagResponse(Request,timeout);
  
  if(ret==1){
                 testStepPass("Suceess to find response of given Request");
                  AssertPass("Suceess to find response of given Request");
    
  }else if (ret==0){
              testStepFail("Failed to find response of given Request: Timeout");
        AssertFail("Failed to find response of given Request: Timeout");
  }else{
    
           testStepFail("Failed to find response of given Request:Internal Error");
        AssertFail("Failed to find response of given Request:Internal Error");
  }
  
  
}

void wait_until_MyRequest_response_and_Compare_results(diagRequest * My_req,diagResponse * My_response, dword sendTimeout,char ResponseString[],char meaning[]){
   int flag;
  byte Actual_Resp_Data[480];
  char string_actual[480]="The Actual Response is :";
  char string_expected[480]="The Expected Response is :";
  char actual_resp_string[400]="";
  char expected_resp_string[400]="";
  char string[400];
  int ResponseCode = 0;
  
  byte Expected_Resp[400];
  int ExpectedResponseLength;
  flag=1;
  ExpectedResponseLength = Convert_String_To_Hex(ResponseString,Expected_Resp);
  
  snprintf(string,400,"check Response Recieved is equal to: %s  ,Which means [%s]",ResponseString,meaning);
  TestExpectation(string);
  
  switch (testWaitForDiagResponse(My_req,sendTimeout)){
    case 1:
    // check that the expected response is equal to actual response
    diagGetLastResponse(My_response);
    diagGetPrimitiveData(My_response , Actual_Resp_Data, ExpectedResponseLength);
    
      write("%d",ExpectedResponseLength);
      write(" length %d",diagGetPrimitiveSize(My_response));
      
  if((ExpectedResponseLength)!=diagGetPrimitiveSize(My_response)){
      testStepFail("Response Recieved not equal in size of Response Expected");
      AssertFail("Response Recieved not equal in size of Response Expected");
  }
  else{
    for ( i = 0 ;i<diagGetPrimitiveSize(My_response); i++)
      {
        snprintf(actual_resp_string, 200," %X",Actual_Resp_Data[i]);
        write("CARE %X",Actual_Resp_Data[i]);
        strncat(string_actual,actual_resp_string,480);
        
        snprintf(expected_resp_string, 200," %X",Expected_Resp[i]);
        strncat(string_expected,expected_resp_string,480);
        
        if(Actual_Resp_Data[i]!=Expected_Resp[i]){
            flag = 0;
        }
      }
      if(flag==0){
          string[0]=0;
          strncat(string,string_expected,4000);
          strncat(string," But ",4000);
          strncat(string,string_actual,4000);
          testStepFail(string);
          AssertFail(string);
      }
      else
      {
        string[0]=0;
        snprintf(string,400,"The Expected Response was equal to The Actual Resonse :%s",string_actual);
        testStepPass(string);
        AssertPass(string);
      }
        write(string_actual);
        write(string_expected);
      break; 
    case 0:
      testStepFail("Response Not Recieved - Timeout");
      AssertFail("Response Not Recieved - Timeout");
      break;
    default:
      testStepFail("Response Not Recieved - Internal Error");
      AssertFail("Response Not Recieved - Internal Error");
      break;  
  }

  }
  string_actual[0]=0;
  string_expected[0]=0;
  actual_resp_string[0]=0;
  expected_resp_string[0]=0;

  
  
}



int WithResultVariable_wait_until_MyRequest_response_and_Compare_results(diagRequest * My_req,diagResponse * My_response, dword sendTimeout,char ResponseString[],char meaning[]){
   int flag;
  byte Actual_Resp_Data[480];
  char string_actual[480]="The Actual Response is :";
  char string_expected[480]="The Expected Response is :";
  char actual_resp_string[400]="";
  char expected_resp_string[400]="";
  char string[400];
  int ResponseCode = 0;
  
  byte Expected_Resp[400];
  int ExpectedResponseLength;
  flag=1;
  ExpectedResponseLength = Convert_String_To_Hex(ResponseString,Expected_Resp);
  
  snprintf(string,400,"check Response Recieved is equal to: %s  ,Which means [%s]",ResponseString,meaning);
  TestExpectation(string);
  
  switch (testWaitForDiagResponse(My_req,sendTimeout)){
    case 1:
    // check that the expected response is equal to actual response
    diagGetLastResponse(My_response);
    diagGetPrimitiveData(My_response , Actual_Resp_Data, ExpectedResponseLength);
    
      write("%d",ExpectedResponseLength);
      write("%d",diagGetPrimitiveSize(My_response));
      
  if((ExpectedResponseLength)!=diagGetPrimitiveSize(My_response)){
      testStepFail("Response Recieved not equal in size of Response Expected");
      AssertFail("Response Recieved not equal in size of Response Expected");
    return 0;
  }
  else{
    for ( i = 0 ;i<diagGetPrimitiveSize(My_response); i++)
      {
        snprintf(actual_resp_string, 200," %X",Actual_Resp_Data[i]);
        strncat(string_actual,actual_resp_string,480);
        
        snprintf(expected_resp_string, 200," %X",Expected_Resp[i]);
        strncat(string_expected,expected_resp_string,480);
        
        if(Actual_Resp_Data[i]!=Expected_Resp[i]){
            flag = 0;
        }
      }
      if(flag==0){
          string[0]=0;
          strncat(string,string_expected,4000);
          strncat(string," But ",4000);
          strncat(string,string_actual,4000);
          testStepFail(string);
          AssertFail(string);
        return 0;
      }
      else
      {
        string[0]=0;
        snprintf(string,400,"The Expected Response was equal to The Actual Resonse :%s",string_actual);
        testStepPass(string);
        AssertPass(string);
        return 1;
      }
        write(string_actual);
        write(string_expected);
      break; 
    case 0:
      testStepFail("Response Not Recieved - Timeout");
      AssertFail("Response Not Recieved - Timeout");
      return 0;
      break;
    default:
      testStepFail("Response Not Recieved - Internal Error");
      AssertFail("Response Not Recieved - Internal Error");
      return 0;
      break;  
  }

  }
  string_actual[0]=0;
  string_expected[0]=0;
  actual_resp_string[0]=0;
  expected_resp_string[0]=0;

  
  
}





void wait_until_MyRequest_response_and_Compare_results_In_range(diagRequest * My_req,diagResponse * My_response, dword sendTimeout,char ResponseString[],char meaning[],int startByte ,int endByte){
  int i;
    int j;
  int flag;
  byte Actual_Resp_Data[480];
  char string_actual[480]="The Actual Response is :";
  char string_expected[480]="The Expected Response is :";
  char actual_resp_string[400]="";
  char expected_resp_string[400]="";
  char string[400];
  int ResponseCode = 0;
  
  byte Expected_Resp[400];
  int ExpectedResponseLength;
  flag=1;
  ExpectedResponseLength = Convert_String_To_Hex(ResponseString,Expected_Resp);
  
  snprintf(string,400,"check Response Recieved is equal to: %s  ,Which means [%s]",ResponseString,meaning);
  TestExpectation(string);
  
  switch (testWaitForDiagResponse(My_req,sendTimeout)){
    case 1:
    // check that the expected response is equal to actual response
    diagGetLastResponse(My_response);
    diagGetPrimitiveData(My_response , Actual_Resp_Data, ExpectedResponseLength);
    
      write("%d",ExpectedResponseLength);
      write("%d",diagGetPrimitiveSize(My_response));
      

    for ( i = startByte ;i<(endByte+1); i++)
      {
        snprintf(actual_resp_string, 200," %X",Actual_Resp_Data[i]);
        strncat(string_actual,actual_resp_string,480);
        
        snprintf(expected_resp_string, 200," %X",Expected_Resp[j]);
        strncat(string_expected,expected_resp_string,480);
        
        if(Actual_Resp_Data[i]!=Expected_Resp[j]){
            flag = 0;
        }
        j=j+1;
      }
      if(flag==0){
          string[0]=0;
          strncat(string,string_expected,4000);
          strncat(string," But ",4000);
          strncat(string,string_actual,4000);
          testStepFail(string);
          AssertFail(string);
      }
      else
      {
        string[0]=0;
        snprintf(string,400,"The Expected Response was equal to The Actual Resonse :%s",string_actual);
        testStepPass(string);
        AssertPass(string);
      }
        write(string_actual);
        write(string_expected);
      break; 
    case 0:
      testStepFail("Response Not Recieved - Timeout");
      AssertFail("Response Not Recieved - Timeout");
      break;
    default:
      testStepFail("Response Not Recieved - Internal Error");
      AssertFail("Response Not Recieved - Internal Error");
      break;  
  

  }
  string_actual[0]=0;
  string_expected[0]=0;
  actual_resp_string[0]=0;
  expected_resp_string[0]=0;

  
  
}

void My_checkDiagnosticsResponseIsPositive(diagRequest * My_req,diagResponse * My_response,dword sendTimeout,char meaning[])
{
  int flag;
  byte Actual_Resp_Data[480];
  char string_actual[480]="The Actual Response is :";
  char string_expected[480]="The Expected Response is :";
  char actual_resp_string[400]="";
  char expected_resp_string[400]="";
  char string[400];
  int ResponseCode = 0;
  
  byte Expected_Resp[400];
  int ExpectedResponseLength;
  flag=1;
  
  TestExpectation(meaning);
  
  switch (testWaitForDiagResponse(My_req,sendTimeout)){
    case 1:
    // check that the reponse is positive
      diagGetLastResponse(My_response);
      if(diagIsPositiveResponse(My_response)==1){
         testStepPass("Positive Response Recieved");
         AssertPass("Positive Response Recieved");
      }
      else
      {
        testStepFail("Response is Negative");
       AssertFail("Response is Negative");
      }
      
      break; 
    case 0:
      testStepFail("Response Not Recieved - Timeout");
      AssertFail("Response Not Recieved - Timeout");
      break;
    default:
      testStepFail("Response Not Recieved - Internal Error");
      AssertFail("Response Not Recieved - Internal Error");
      break;  
  }

 }

void check_No_My_Diag_response(diagRequest * req, dword sendTimeout){
  int ret=0;
  TestAction("wait until Response Not Found");
 
  
  ret=testWaitForDiagResponse(req,sendTimeout);
  
  if(ret==1){
      testStepFail("Response Recieved while expecting No Response");
      AssertFail("Response Recieved while expecting No Response");
    
  }else if (ret==0){
              testStepPass("Failed to find response of given Request: Timeout");
        AssertPass("Failed to find response of given Request: Timeout");
  }else{
    
           testStepFail("Failed to find response of given Request:Internal Error");
        AssertFail("Failed to find response of given Request:Internal Error");
  }
  

  
  
}









void CheckDTCAvailable( int timeout, dword DTC_To_be_checked, byte checkMask)
{ 
  long ret, ret2, ret3;
  long length;
 byte StatusByte;
 byte bit;
 char text[200];
 int i =0;
 dword DTC;
    char string[400];
    if(DTC_To_be_checked== NoDTC){
    
    TestExpectation("Checking DTCs response :No DTCs");
    
  } else if(DTC_To_be_checked== IgnDTC){
    
    TestExpectation("Checking DTCs response :Expected Ignition DTC");
    
  } else if(DTC_To_be_checked== NoIgnDTC){
    
    TestExpectation("Checking DTCs response :No Ignition DTC");
    
  } else if(DTC_To_be_checked== NormDTC){
    
    TestExpectation("Checking DTCs response : Expected Normal Volt ,No High or Low Volt DTCs");
    
  }else if(DTC_To_be_checked== HighDTC){
    TestExpectation("Checking DTCs response : Expected  High Volt DTCs");
  }else if (DTC_To_be_checked== LowDTC){
     TestExpectation("Checking DTCs response : Expected Low Volt DTCs");
  }
  else if(DTC_To_be_checked== PN14_NormDTC){
    
    TestExpectation("Checking DTCs response : Expected PN14_Normal Volt ,No PN14_High or PN14_Low Volt DTCs");
    
  }else if(DTC_To_be_checked== PN14_HighDTC){
    TestExpectation("Checking DTCs response : Expected  PN14_High Volt DTCs");
  }else if (DTC_To_be_checked== PN14_LowDTC){
     TestExpectation("Checking DTCs response : Expected PN14_Low Volt DTCs");
  }
  
  
  
  ret = testWaitForDiagRequestSent(req_To_get_DTCs,timeout);
  
   if(ret==1){ // Request sent
    
     ret2=testWaitForDiagResponse(req_To_get_DTCs,timeout);
      if(ret2 ==1){ //response recieved
       ret3= diagGetLastResponse(req_To_get_DTCs,resp_To_get_DTCs);
       
        if(ret3>=0){ // retrieved response
          if(0 != diagIsPositiveResponse(resp_To_get_DTCs) ){   //a positive response
            
            length = diagGetIterationCount(resp_To_get_DTCs, "DTCAndStatusRecord"); // Get then number of iterations
 
            
            if(length >= 0 ){
              
                          if(DTC_To_be_checked == NoDTC  ){
                if(length == 0){         
                   testStepPass("No DTCs found as expected");
                  AssertPass("No DTCs found as expected");
                }else{

                
                 DTC=DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
                 DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
                 StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
                 
              
         
                                                                                             string[0]=0;
        snprintf(string,400," DTC  was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte );
        testStepFail(string);
        AssertFail(string);
                  
                  


                  
            
                } 
              }
              
              
              else  if(DTC_To_be_checked == NoIgnDTC  ){
                if(length == 0){         
                   testStepPass("No DTCs found as expected");
                  AssertPass("No DTCs found as expected");
                }else{
                  testStepWarning("found Multiple DTCs but was expected None");
                 
                 for(i=0;i<length;i++){
                 DTC=DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
                 DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
                 StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
                 
                  if(  ( (DTC==IgnDTC )&& (StatusByte==checkMask) )  ){
         
                                                                                             string[0]=0;
        snprintf(string,400,"Ignition DTC  was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte );
        testStepFail(string);
        AssertFail(string);
                  
                  
                  break;
                }
                else if(i!=length-1) continue;
                else{
                  testStepPass("Ignition DTC Not found as expexted" );
                  AssertPass("Ignition DTC Not found as expexted");
                  break;
                }
                  
                }
                } 
              }
            else  if(DTC_To_be_checked == NormDTC  ){
                if(length == 0){         
                   testStepPass("No DTCs found as expected");
                  AssertPass("No DTCs found as expected");
                }else{
                  testStepWarning("found Multiple DTCs but was expected None");
                 
                 for(i=0;i<length;i++){
                 DTC=DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
                 DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
                 StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
                 
                  if(((DTC==HighDTC )&& (StatusByte==checkMask))||((DTC==LowDTC )&& (StatusByte==checkMask))){
         
                                                                                             string[0]=0;
        snprintf(string,400,"High OR Low DTC  was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte );
        testStepFail(string);
        AssertFail(string);
                  
                  
                  break;
                }
                else if(i!=length-1) continue;
                else{
                  testStepPass("High & Low Not found as expexted" );
                  AssertPass("High & Low Not found as expexted");
                  break;
                }
                  
                }
                } 
              }else if(DTC_To_be_checked == PN14_NormDTC  ){
                if(length == 0){         
                   testStepPass("No DTCs found as expected");
                  AssertPass("No DTCs found as expected");
                }else{
                  testStepWarning("found Multiple DTCs but was expected None");
                 
                 for(i=0;i<length;i++){
                 DTC=DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
                 DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
                 StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
                 
                  if(((DTC== PN14_HighDTC )&& (StatusByte==checkMask))||((DTC== PN14_LowDTC )&& (StatusByte==checkMask))){
         
                                                                                             string[0]=0;
        snprintf(string,400," PN14 High OR Low Volt DTC  was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte );
        testStepFail(string);
        AssertFail(string);
                  
                  
                  break;
                }
                else if(i!=length-1) continue;
                else{
                  testStepPass("High & Low Not found as expexted" );
                  AssertPass("High & Low Not found as expexted");
                  break;
                }
                  
                }
                } 
              }
            
            
            else{
              
//              if(length ==1)
//              {
//              
//              DTC=DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
//              DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
//              StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
//
//                if((DTC==DTC_To_be_checked )&& (StatusByte==checkMask)){
//                                                                             string[0]=0;
//        snprintf(string,400,"CheckDTCAvailableBBB","DTC to be checked was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte);
//        testStepPass(string);
//        AssertPass(string);
//                  
//                  
//                }else{
//                                                                           string[0]=0;
//        snprintf(string,400,"DTC %06X to be checked was Not found, Instead Found DTC %06X - %s  - StatusByte: %02X",DTC_To_be_checked,DTC,text,StatusByte);
//        testStepFail(string);
//        AssertFail(string);
//                  
//                 
//                }
//                
//                
//              }else
//{
//                
           //     testStepWarning("CheckDTCAvailable","found Multiple DTCs but was expected one");
                
                if(length==0){
                          snprintf(string,400,"DTC %06X to be checked was Not found, Instead Found No DTC  ",DTC_To_be_checked);
        testStepFail(string);
        AssertFail(string);
                  return;
                }
                
                
                
                for(i=0;i<length;i++){
                 DTC=DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
                 DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
                 StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
                 if((DTC==DTC_To_be_checked )&& (StatusByte==checkMask)){
               
                                                         string[0]=0;
        snprintf(string,400,"DTC to be checked was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte);
        testStepPass(string);
        AssertPass(string);
                  
                  break;
                }
                else if(i!=length-1) continue;
                else{
                  
                 
                                       string[0]=0;
        snprintf(string,400,"DTC %06X to be checked was Not found, Instead Found DTC %06X - %s  - StatusByte: %02X",DTC_To_be_checked,DTC,text,StatusByte);
        testStepFail(string);
        AssertFail(string);
                  
                  break;
                }
                  
                }

                

                
//              }
              
              }
            }
            else{ 
              

                      string[0]=0;
        snprintf(string,400,"Error retrieving iteration length: %d", length);
        testStepFail(string);
        AssertFail(string);
            }


            
            
          }else{// a negative response
             diagGetParameter(resp_To_get_DTCs, "RC", text,  elCount(text)); // get the symbolic value of the response code
          
         string[0]=0;
        snprintf(string,400,"Negative response received.\nNegative response code: 0x%02X - %s",  (byte)DiagGetResponseCode(resp_To_get_DTCs), text);
        testStepFail(string);
        AssertFail(string);
            

          }
          
        }else{  //Could not retrieve response
          
          
                testStepFail("Could not retrieve response");
      AssertFail("Could not retrieve response");
        }
        
        
        
      }else{ //response not recieved
             
      testStepFail("Response Not Recieved - Timeout");
      AssertFail("Response Not Recieved - Timeout");
      }
    
    
   }else{ // Request not sent
     

      testStepFail("Request Not Sent - Timeout");
      AssertFail("Request Not Sent - Timeout");
   }
  
  
  
}




void CheckDTCAvailable_OffBoard( int timeout, dword DTC_To_be_checked, byte checkMask)
{ 
  long ret, ret2, ret3;
  long length;
 byte StatusByte;
 byte bit;
 char text[200];
 int i =0;
 dword DTC;
    char string[400];
  
      if(DTC_To_be_checked== NoDTC){
    
    TestExpectation("Checking DTCs response :No DTCs");
    
  }else if(DTC_To_be_checked== IgnDTC){
    
    TestExpectation("Checking DTCs response :Expected Ignition DTC");
    
  } else if(DTC_To_be_checked== NoIgnDTC){
    
    TestExpectation("Checking DTCs response :No Ignition DTC");
    
  } else if(DTC_To_be_checked== NormDTC){
    
    TestExpectation("Checking DTCs response : Expected Normal Volt ,No High or Low DTCs");
    
  }else if(DTC_To_be_checked== HighDTC){
    TestExpectation("Checking DTCs response : Expected  High DTCs");
  }else if (DTC_To_be_checked== LowDTC){
     TestExpectation("Checking DTCs response : Expected Low Volt DTCs");
  }
  else if(DTC_To_be_checked== PN14_NormDTC){
    
    TestExpectation("Checking DTCs response : Expected PN14_Normal Volt ,No PN14_High or PN14_Low Volt DTCs");
    
  }else if(DTC_To_be_checked== PN14_HighDTC){
    TestExpectation("Checking DTCs response : Expected  PN14_High Volt DTCs");
  }else if (DTC_To_be_checked== PN14_LowDTC){
     TestExpectation("Checking DTCs response : Expected PN14_Low Volt DTCs");
  }
  
  
  
  ret = testWaitForDiagRequestSent(req_To_get_DTCs_OffBoard,timeout);
  
   if(ret==1){ // Request sent
    
     ret2=testWaitForDiagResponse(req_To_get_DTCs_OffBoard,timeout);
      if(ret2 ==1){ //response recieved
       ret3= diagGetLastResponse(req_To_get_DTCs_OffBoard,resp_To_get_DTCs_OffBoard);
       
        if(ret3>=0){ // retrieved response
          if(0 != diagIsPositiveResponse(resp_To_get_DTCs_OffBoard) ){   //a positive response
            
            length = diagGetIterationCount(resp_To_get_DTCs_OffBoard, "DTCAndStatusRecord"); // Get then number of iterations
 
            
            if(length >= 0 ){
              
                        if(DTC_To_be_checked == NoDTC  ){
                if(length == 0){         
                   testStepPass("No DTCs found as expected");
                  AssertPass("No DTCs found as expected");
                }else{

                
                 DTC=DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
                 DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
                 StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
                 
              
         
                                                                                             string[0]=0;
        snprintf(string,400," DTC  was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte );
        testStepFail(string);
        AssertFail(string);
                  
                  


                  
            
                } 
              }
              
              
              else  if(DTC_To_be_checked == NoIgnDTC  ){
                if(length == 0){         
                   testStepPass("No DTCs found as expected");
                  AssertPass("No DTCs found as expected");
                }else{
                  testStepWarning("found Multiple DTCs but was expected None");
                 
                 for(i=0;i<length;i++){
                 DTC=DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
                 DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
                 StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
                 
                  if(  ( (DTC==IgnDTC )&& (StatusByte==checkMask) )  ){
         
                                                                                             string[0]=0;
        snprintf(string,400,"Ignition DTC  was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte );
        testStepFail(string);
        AssertFail(string);
                  
                  
                  break;
                }
                else if(i!=length-1) continue;
                else{
                  testStepPass("Ignition DTC Not found as expexted" );
                  AssertPass("Ignition DTC Not found as expexted");
                  break;
                }
                  
                }
                } 
              }
            else  if(DTC_To_be_checked == NormDTC  ){
                if(length == 0){         
                   testStepPass("No DTCs found as expected");
                  AssertPass("No DTCs found as expected");
                }else{
                  testStepWarning("found Multiple DTCs but was expected None");
                 
                 for(i=0;i<length;i++){
                 DTC=DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
                 DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
                 StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
                 
                  if(((DTC==HighDTC )&& (StatusByte==checkMask))||((DTC==LowDTC )&& (StatusByte==checkMask))){
         
                                                                                             string[0]=0;
        snprintf(string,400,"High OR Low DTC  was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte );
        testStepFail(string);
        AssertFail(string);
                  
                  
                  break;
                }
                else if(i!=length-1) continue;
                else{
                  testStepPass("High & Low Not found as expexted" );
                  AssertPass("High & Low Not found as expexted");
                  break;
                }
                  
                }
                } 
              }
            
            
            else if(DTC_To_be_checked == PN14_NormDTC  ){
                if(length == 0){         
                   testStepPass("No DTCs found as expected");
                  AssertPass("No DTCs found as expected");
                }else{
                  testStepWarning("found Multiple DTCs but was expected None");
                 
                 for(i=0;i<length;i++){
                 DTC=DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
                 DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
                 StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
                 
                  if(((DTC== PN14_HighDTC )&& (StatusByte==checkMask))||((DTC== PN14_LowDTC )&& (StatusByte==checkMask))){
         
                                                                                             string[0]=0;
        snprintf(string,400," PN14 High OR Low Volt DTC  was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte );
        testStepFail(string);
        AssertFail(string);
                  
                  
                  break;
                }
                else if(i!=length-1) continue;
                else{
                  testStepPass("High & Low Not found as expexted" );
                  AssertPass("High & Low Not found as expexted");
                  break;
                }
                  
                }
                } 
              }
            
            
            
            
            
            
            else{
              
//              if(length ==1){
//              
//              DTC=DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
//              DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
//              StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
//
//                if((DTC==DTC_To_be_checked )&& (StatusByte==checkMask)){
//                                                                             string[0]=0;
//        snprintf(string,400,"CheckDTCAvailable","DTC to be checked was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte);
//        testStepPass(string);
//        AssertPass(string);
//                  
//                  
//                }else{
//                                                                           string[0]=0;
//        snprintf(string,400,"DTC %06X to be checked was Not found, Instead Found DTC %06X - %s  - StatusByte: %02X",DTC_To_be_checked,DTC,text,StatusByte);
//        testStepFail(string);
//        AssertFail(string);
//                  
//                 
//                }
//                
//                
//              }else{
                
            //    testStepWarning("CheckDTCAvailable","found Multiple DTCs but was expected one");
                
                                if(length==0){
                          snprintf(string,400,"DTC %06X to be checked was Not found, Instead Found No DTC  ",DTC_To_be_checked);
        testStepFail(string);
        AssertFail(string);
                  return;
                }
                
                
                for(i=0;i<length;i++){
                 DTC=DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord",i,"DTCRecord"); // get the DTC
                 DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "DTCRecord" , text, elCount(text)); // get the corresponding DTC text
                 StatusByte=(byte)DiagGetComplexParameter(resp_To_get_DTCs_OffBoard,"DTCAndStatusRecord", i, "StatusOfDTC"); // get DTC status byte
                 if((DTC==DTC_To_be_checked )&& (StatusByte==checkMask)){
               
                                                         string[0]=0;
        snprintf(string,400,"DTC to be checked was found, DTC %06X - %s  - StatusByte: %02X",DTC,text,StatusByte);
        testStepPass(string);
        AssertPass(string);
                  
                  break;
                }
                else if(i!=length-1) continue;
                else{
                  
                 
                                       string[0]=0;
        snprintf(string,400,"DTC %06X to be checked was Not found, Instead Found DTC %06X - %s  - StatusByte: %02X",DTC_To_be_checked,DTC,text,StatusByte);
        testStepFail(string);
        AssertFail(string);
                  
                  break;
                }
                  
                }

                

                
//              }
              
              }
            }
            else{ 
              

                      string[0]=0;
        snprintf(string,400,"Error retrieving iteration length: %d", length);
        testStepFail(string);
        AssertFail(string);
            }


            
            
          }else{// a negative response
             diagGetParameter(resp_To_get_DTCs_OffBoard, "RC", text,  elCount(text)); // get the symbolic value of the response code
          
         string[0]=0;
        snprintf(string,400,"Negative response received.\nNegative response code: 0x%02X - %s",  (byte)DiagGetResponseCode(resp_To_get_DTCs_OffBoard), text);
        testStepFail(string);
        AssertFail(string);
            

          }
          
        }else{  //Could not retrieve response
          
          
                testStepFail("Could not retrieve response");
      AssertFail("Could not retrieve response");
        }
        
        
        
      }else{ //response not recieved
             
      testStepFail("Response Not Recieved - Timeout");
      AssertFail("Response Not Recieved - Timeout");
      }
    
    
   }else{ // Request not sent
     

      testStepFail("Request Not Sent - Timeout");
      AssertFail("Request Not Sent - Timeout");
   }
  
  
  
}



Send_diagRequest_To_Extended_start(){
  TestAction("Start Extended season");
  diagSendRequest(req_To_Extended_start);
}

Send_diagRequest_To_Default_start(){
  TestAction("Start Default season");
  diagSendRequest(req_To_default_start);
}


Send_diagRequest_To_DTC_Logging_OFF(){
  TestAction(" DTC Logging OFF");
  diagSendRequest(req_DTC_Logging_OFF);
}

Send_diagRequest_To_DTC_Logging_ON(){
  TestAction(" DTC Logging ON");
  diagSendRequest(req_DTC_Logging_ON);
 
}

Ingnition_Reset(){
  TestAction(" Ingnition Reset");
   
  @sysvar::IL::Klemme15=0;
   Ingnition_State(0);
  testWaitForTimeout(8000);
  @sysvar::IL::Klemme15=1;
  Ingnition_State(4);
  testWaitForTimeout(8000);
}

Ingnition_Reset_short_time(){
  TestAction(" Ingnition Reset");
   
  @sysvar::IL::Klemme15=0;
   Ingnition_State(0);
  testWaitForTimeout(2000);
  @sysvar::IL::Klemme15=1;
  Ingnition_State(4);
  testWaitForTimeout(2000);
}

Ingnition_OFF(){
  TestAction(" Ingnition OFF");
   
  @sysvar::IL::Klemme15=0;
  testWaitForTimeout(8000);

}

Ingnition_ON(){
  TestAction(" Ingnition ON and its state to 4 (ON)");
   

  @sysvar::IL::Klemme15=1;
  
  Ingnition_State(4);
  
  testWaitForTimeout(8000);
}

Ingnition_State(int state){
    char string[400];

   snprintf(string,400," Ingnition state %d",state);
  TestAction(string);

   
  setSignalwithValue(ISw_Stat_ST3,state,string);
  //sysSetVariableInt(sysvar::ModelGlobal::ISw_Stat,state);
  
}

TransMd_State(int state){
    char string[400];

   snprintf(string,400," TransMd state %d",state);

  setSignalwithValue(PN14_TransMd_Stat_ST3,state,string);
  
}


void My_diagSendRequest_ECU_soft_reset(){
  TestAction(" ECU_soft_reset");
   

    diagSendRequest(req_To_ECU_soft_reset);
  testWaitForTimeout(8000);
}


void My_diagSendRequest_ECU_hard_reset(){
  TestAction(" ECU_hard_reset");
   

    diagSendRequest(req_To_ECU_hard_reset);
  testWaitForTimeout(8000);
}



void Start_diagTesterPresent()
{
  TestAction("Start diagTesterPresent");
  diagStartTesterPresent();
}

void Stop_diagTesterPresent()
{
  TestAction("Stop diagTesterPresent");      
  diagStopTesterPresent();
  testWaitForTimeout(200);
}

  
void check_session(byte session_To_be_checked)
{
  byte active_session;

  int ret,ret2,ret3;
  char string[400];
  
    snprintf(string,400,"check Seasion Recieved : Expected Seasion = %02X   ",session_To_be_checked);
  TestExpectation(string);
  
  
  diagSendRequest(req_To_get_current_session);
   ret = testWaitForDiagRequestSent(req_To_get_current_session,2000);
  
   if(ret==1){ // Request sent
    
     ret2=testWaitForDiagResponse(req_To_get_current_session,2000);
      if(ret2 ==1){ //response recieved
      ret3= diagGetLastResponse(req_To_get_current_session,resp_To_get_current_session);
      
       if(ret3>=0){ // retrieved response
         if(0 != diagIsPositiveResponse(resp_To_get_DTCs) ){   //a positive response
          
         active_session=  (byte)diagGetParameter(resp_To_get_current_session,"Session.Active_Diagnostic_Session");
          
          if(active_session==session_To_be_checked){
                               string[0]=0;
        snprintf(string,400,"Correct Current session Found session = %02X   ",active_session);
        testStepPass(string);
        AssertPass(string);
            
            
        
    
  }else{

    
       snprintf(string,400,"Wrong Current session , Found session = %02X   ", active_session );
        testStepFail(string);
        AssertFail(string);
  }
          
         }else{
            testStepFail("Neg Response failed"   );
          AssertFail("Neg Response failed"   );
         }
       }else{
         testStepFail("retrieve Response failed"   );
        AssertFail("retrieve Response failed"   );
       }
      
        }else{
          testStepFail("testWaitForDiagResponse() failed"   );
          AssertFail("testWaitForDiagResponse() failed"   );
        }
          
  } else{
            
            testStepFail("testWaitForDiagRequestSent() failed"   );
    AssertFail("testWaitForDiagRequestSent() failed"   );
          }
          
  
  
}



void Flash_intialize(){

  

  
power_intialize();
  
  
}

void intialize(){
    TestAction("Setting diagSetTarget To SWSP174_Int");   
     diagSetTarget("SWSP174_Int");
  testWaitForTimeout(200);
  Stop_diagTesterPresent();
  
      TestAction("Setting diagSetTarget To SWSP174");   
   diagSetTarget("SWSP174");
  testWaitForTimeout(200);
  Stop_diagTesterPresent();
  

  
power_intialize();
  
    Ingnition_ON();

    sendDiagnosticsRequest("0x14 0xFF 0xFF 0xFF","ClearDTCs");
 // checkDiagnosticsResponse("0x54",1000,"Check DTCsClear diag response"); 
  
  
  Start_Frame("SCCM_STEERING_WHEEL_Container1_ST3_Ign_Stat_ST3");
 // deAuthentication();
  //diagSendRequest(req_To_Deauthenticate);
  
  //Enable DTC Logging 
//  Authentication();
  
//   diagSendRequest(req_To_Extended_start);
//  
//    check_session(extented_session);
//  
//  diagSendRequest(req_DTC_Logging_ON);
  
}

void intialize_OffBoard(){
  
    TestAction("Setting diagSetTarget To SWSP174"); 
     diagSetTarget("SWSP174");
  testWaitForTimeout(2000);
  Stop_diagTesterPresent();
  
  TestAction("Setting diagSetTarget To SWSP174_Int"); 
   diagSetTarget("SWSP174_Int");
  testWaitForTimeout(2000);
  Stop_diagTesterPresent();
  

power_intialize();
  
    Ingnition_ON();
  
    sendDiagnosticsRequest_OffBoard("0x14 0xFF 0xFF 0xFF","ClearDTCs");
 // checkDiagnosticsResponse_OffBoard("0x54",1000,"Check DTCsClear diag response"); 
  
  
  Start_Frame("SCCM_STEERING_WHEEL_Container1_ST3_Ign_Stat_ST3");
 // deAuthentication();
  //diagSendRequest(req_To_Deauthenticate);
  
  //Enable DTC Logging 
//  Authentication();
  
//   diagSendRequest(req_To_Extended_start);
//  
//    check_session(extented_session);
//  
//  diagSendRequest(req_DTC_Logging_ON);
  
}

void Authentication()
{
  
  int check=0;
TestAction("Authenticate");

  sysSetVariableInt( sysvar::DAG_Diagnostics::DiagnosticsRole,2);
  testWaitForTimeout(500);
  sysSetVariableInt( sysvar::LocalAuthentication::Button_Authenticate,1);
  testWaitForTimeout(3000);
        sysSetVariableInt( sysvar::LocalAuthentication::Button_Authenticate,0);
     testWaitForTimeout(3000);
   check= sysGetVariableInt( sysvar::LocalAuthentication::AuthResult);

  TestExpectation("Authenticate Successfully");
  
    if(check==1){
      testStepPass("Authenticated Successfully");
      AssertPass("Authorized Successfully");
  }else{
    
    testStepFail("Authenticated Failed");
    AssertFail("Authenticated Failed");
  }
  
}


void Authentication_X(int x)
{
  
  int check=0;
TestAction("Authenticate");

  sysSetVariableInt( sysvar::DAG_Diagnostics::DiagnosticsRole,x);
  
  testWaitForTimeout(500);
  sysSetVariableInt( sysvar::LocalAuthentication::Button_Authenticate,1);
  testWaitForTimeout(3000);
        sysSetVariableInt( sysvar::LocalAuthentication::Button_Authenticate,0);
     testWaitForTimeout(3000);
   check= sysGetVariableInt( sysvar::LocalAuthentication::AuthResult);

  TestExpectation("Authenticate Successfully");
  
    if(check==1){
      testStepPass("Authenticated Successfully");
      AssertPass("Authorized Successfully");
  }else{
    
    testStepFail("Authenticated Failed");
    AssertFail("Authenticated Failed");
  }
  
}

void power_reset()
{
  testWaitForTimeout(5000);
  
 PowerSetTo(0.00);
  

  testWaitForTimeout(5000);
  
 PowerSetTo(12.00);
  
  testWaitForTimeout(5000);
  
}

void power_reset_long_delay()
{
  
  
 PowerSetTo(0.00);
  

  testWaitForTimeout(15000);
  
 PowerSetTo(12.00);
  
  testWaitForTimeout(5000);
  
}

diagSendRequest_To_Get_DTCs( byte StatusMask ){
  
  char string[400];
 
  string[0]=0;
   snprintf(string,400,"Send Diagnostics Request To Get DTCs : with StatusMask %02X   ",StatusMask);
  TestAction(string);
  diagSetParameter(req_To_get_DTCs, "DTCStatusMask", StatusMask);
  //diagSendRequest_To_Get_DTCs( StatusMask); // send Req to find DTCs with Status Mask
  diagSendRequest(req_To_get_DTCs);
  
}
diagSendRequest_To_Get_DTCs_OffBoard( byte StatusMask ){
  char string[400];
  string[0]=0;
   snprintf(string,400,"Send Diagnostics Request To Get DTCs : with StatusMask %02X   ",StatusMask);
  TestAction(string);
   diagSetParameter(req_To_get_DTCs, "DtcStatusMask", StatusMask);
  //diagSendRequest_To_Get_DTCs( StatusMask); // send Req to find DTCs with Status Mask
  diagSendRequest(req_To_get_DTCs_OffBoard);
  
}


void CheckVH1150Availability_Reconnect()
{
  int retVal=-4;
  if (@sysvar::VH1150::VH_avalible ==0)
    {
      // VH Not Avalible, will try to connect
      sysSetVariableInt(sysvar::VH1150::OpenSearch, 1);
      retVal= testWaitForSysVar(sysvar::VH1150::VH_avalible,2000);
      if (retVal == 1)      
      {
        write ("Successfully connected to VH1150, from CI Test Module");
        sysSetVariableInt(sysvar::VH1150::Power, 1); //Enable relays
      }
      else
      {
        write("Failed to Connect to VH1150, Switching to Toellner for manual handling of Power Reset");
        sysSetVariableInt(sysvar::Power_choice::Power_choice_btn, 0);
      }
    }
}
void power_intialize()
{
  TestAction("Intialize Power");   
//VH1150 Choosen in panel
  if(@sysvar::Power_choice::Power_choice_btn==1)
  {
    sysSetVariableInt(sysvar::Power_choice::Power_choice_btn,1);
    
    CheckVH1150Availability_Reconnect();
    // VH Avalible
    if (@sysvar::VH1150::VH_avalible ==1)
    {
      //Power Reset
      // Set Volt to 0 Volt
      sysSetVariableFloat(sysvar::VH1150::SetVoltageVBatt,0.0);
      testWaitForTimeout(1500);
      sysSetVariableFloat(sysvar::VH1150::SetVoltageVBatt,12.0);
      testWaitForTimeout(1500);
      testStepPass("VH1150 is connected & Resetted");
      }
    //VH Not Avalible
    else
      {
        Authentication();
      HardReset(2000);
       }

  }
  
  else{//TOELLNER Choosen in panel
    
    
     if(getvalue(Power_Supply_connection_verified)==1){
        //Power Reset
    
   //Set Volt to 0 Volt
 Power_Supply_SelectChannel(01);
 testWaitForTimeout(1000);
 Power_Supply_Volt_Set_Absolute(0.00);
 testWaitForTimeout(1000);
     //Set Volt to 12 Volt
 Power_Supply_Volt_Set_Absolute(12.00);
 testWaitForTimeout(1000);
    
  }
    else {
      Authentication();
      HardReset(2000);
    }
      
    }


}

HardReset(int testWaitAfterDiagRequest)
{
  
  sendDiagnosticsRequest("0x11 0x01","Hard Reset using service 0x11 and subfunction 0x01");
  checkDiagnosticsResponse("0x51 01",2000,"Check HardReset positive response"); 
  testWaitForTimeout(testWaitAfterDiagRequest);
}



PowerSetTo(float volt ){
  char string[400];
  char string2[400];
   snprintf(string,400,"Power set to : %f volt",volt);
  TestAction(string);

//VH1150 Choosen in panel
  if(@sysvar::Power_choice::Power_choice_btn==1){
    
      //VH Avalible
   if (@sysvar::VH1150::VH_avalible ==1){
   

    sysSetVariableFloat(sysvar::VH1150::SetVoltageVBatt,volt);
    snprintf(string2,400,"VH1150 is connected & Volt is set to : %f volt",volt );
  testStepPass(string2);
  }
//VH Not Avalible
  else{
        testStepFail("VH1150 can't be connected & Volt set Failled %s");
  }
  
  }
  else{
  //  Power_Supply_SelectChannel(channel);
 // testWaitForTimeout(2000);
  Power_Supply_Volt_Set_Absolute(volt);
  
}
}


testWait(dword timeout ){
  char string[400];
  
   snprintf(string,400,"Test wait  : %d",timeout);
  TestAction(string);
  
   
 testWaitForTimeout(timeout);
  
  
  
}

int ForAction_testWaitForTesterConfirmation(char meaning[]){
  int ret;
  TestAction(meaning);
 ret= testWaitForTesterConfirmation(meaning);
  
  return ret;
}



Requestseed_and_CheckResponse(byte seed[],char meaning[]){
  
  char buffer[100];
  long ret, ret2, ret3;
 TestAction(meaning);
  
  

  diagGetObjectName(seedReq, buffer, elCount(buffer)); // Get the name of the diagnostic object
  DiagSendRequest(seedReq); // Send request security seed
  ret = testWaitForDiagRequestSent(seedReq, 2000); // Wait until the request has been completely sent
  if(ret==1) // Request sent
  {
     TestReportWriteDiagObject(seedReq); // Write the request-Object to the testreport
     write("Request %s has been successfully sent", buffer);
    
     TestExpectation("Get Response with Seed and store it");
     ret2=TestWaitForDiagResponse(seedReq, 5000); // Wait for a response, here for 5000ms. Note: This is no P2 timeout!
        
     if(ret2==1) // Response received
     {
        ret3=DiagGetLastResponseCode(seedReq); // Get the code of the receveived response
        if(ret3 == -1) // Positive response received
        {
          diagGetRespParameterRaw(seedReq, "Request_Seed", seed, elCount(seed)); // Retrieve the seed
    //  write("Seed is: 0x%02X%02X%", seed[0],seed[1]);
          testReportWriteDiagResponse(seedReq); // Write the response to the testreport
               testStepPass(0, "1.0", "Positive Response  with seed  upon Request %s", buffer); // teststep Pass  
             AssertPass("Positive response with seed as expected");
        }
        else // Negative response received
        {
          write("Negative Response upon Request %s, NRC: 0x%02X", buffer, (byte)ret3);
          TestReportWriteDiagResponse(seedReq); // Write the response-Object to the testreport
          testStepFail(0, "1.0", "Negative Response upon Request %s, NRC: 0x%02X", buffer, (byte)ret3); // teststep failed  
          AssertFail("Negative Response of Seed Request");
        }
     }
     else
     {
        DiagResponseError(ret2);
     }
   }
   else
   {
      DiagRequestSentError(ret, buffer);
   }       
  

  //Also Check for length Seed 256 bit-
}
Generate_key(byte seed[],byte key_s[],char meaning[]){
  int i;
    char buffer[100];
  long ret, ret2, ret3;
  dword keySizeOut = 0;
  
   TestAction(meaning);

  write("Key array size %d", elcount(key_s));
//   KeYGenStatus = TestWaitForGenerateKeyFromSeed(seed, elCount(seed), 17,key_s ,elcount(key_s), keySizeOut, 500); // form 1
            // Generate key from seed. Wait max 5000ms for the function in the DLL to return.
         //KeYGenStatus = testWaitForGenerateKeyFromSeed( seed, elCount(seed), 11, key_s, elCount(key_s), keySizeOut, 5000); 
            // KeYGenStatus = testWaitForGenerateKeyFromSeed( "SWSP174",seed, elCount(seed), 12,"R2 Valeo","", key_s, elCount(key_s), keySizeOut, 5000); 
      KeYGenStatus = testWaitForGenerateKeyFromSeed( "SWSP174",seed, elCount(seed), 0x11,"R4 Valeo","",  key_s, elCount(key_s), keySizeOut, 5000); 
  write("Return from TestWaitForGenerateKeyFromSeed %d,  The Key %d Seed : %d - %d" ,KeYGenStatus ,keySizeOut,elCount(seed) ,elCount(key_s));
  TestExpectation(" Key Generated from Seed");
              for(i=0;i<32;i++){
write("K1::: 0x%02X%", key_s[i]);
              write("key count::: %d", elCount(key_s));
              write("key size::: %d", keySizeOut);
              
  }
         if(KeYGenStatus==1) // Key generation successful
          {
            
                          write("Success key generation");
              teststepPass(0, "1.0", "Success key generation"); // teststep failed
            AssertPass("Success key generation");
   }
          else
          {
            if(KeYGenStatus==0)
            {
              write("Timeout during key generation");
              teststepfail(0, "1.0", "Timeout during key generation"); // teststep failed
              AssertFail("Timeout during key generation");
            }
            else
            {
              write("Error code %d during key calculation",KeYGenStatus);
              teststepfail(0, "1.0", "Error code %d during key calculation",KeYGenStatus);
                  AssertFail("Error code during key calculation");
            }
          }
       
}
  Sendkey_and_CheckResponse(byte key_s[],char meaning[]){
    
        char buffer[100];
  long ret, ret2, ret3;
  dword keySizeOut;

     TestAction(meaning);

    
    
    //        write("Key is: 0x%02X%02X", key_s[0], key_s[1]);
            diagSetParameterRaw(keyReq, "Send_Key", key_s, elCount(key_s)); // Set the key in the request-object
            diagGetObjectName(keyReq, buffer, elCount(buffer));
            
            DiagSendRequest(keyReq); // Request security seed
    
       TestExpectation("Get Positive Response of Key request: ECU unlocked for level 1");
            ret = testWaitForDiagRequestSent(keyReq, 2000); // Wait until the request has been completely sent
            if(ret==1) //Request sent
            {
              TestReportWriteDiagObject(keyReq); // Write the request-Object to the testreport
              write("Request %s has been successfully sent", buffer);
              ret2=TestWaitForDiagResponse(keyReq, 5000); // Wait for a response, here for 5000ms. Note: This is no P2 timeout!  
              if(ret2 == 1) // Response received
              {
                ret3=DiagGetLastResponseCode(keyReq); // Get the code of the receveived response
                if(ret3 == -1) // Positive response received
                {
                  write("ECU unlocked for level 1");
                  testReportWriteDiagResponse(keyReq);
                  testStepPass(0, "1.0", "ECU unlocked for level 11");
                  AssertPass("ECU unlocked for level 11");
                }
                else // Negative response received
                {
                  write("Negative Response upon Request %s, NRC: 0x%02X",buffer, (byte)ret3);
                  TestReportWriteDiagResponse(seedReq); // Write the response-Object to the testreport
                  testStepFail(0, "1.0", "Negative Response upon Request %s, NRC: 0x%02X",buffer, (byte)ret3); // teststep failed  
                  AssertFail("Negative Response upon Request");
                }
              }
              else
              {
                DiagResponseError(ret2);  
              }
            }
            else
            {
              DiagRequestSentError(ret, buffer);  
            }
         
    
  }
    Sendkey_NoResponseCheck(byte key_s[]){
      
    char buffer[100];
  long ret, ret2, ret3;
  dword keySizeOut;
      
           TestAction("Send request with key");
      
    //        write("Key is: 0x%02X%02X", key_s[0], key_s[1]);
            diagSetParameterRaw(keyReq, "Send_Key", key_s, elCount(key_s)); // Set the key in the request-object
            diagGetObjectName(keyReq, buffer, elCount(buffer));
            
            DiagSendRequest(keyReq); // Request security seed

      TestExpectation("Success in Sending request with key");
                  ret = testWaitForDiagRequestSent(keyReq, 2000); // Wait until the request has been completely sent
            if(ret==1) //Request sent
            {
                                        write("Success key Sent");
              teststepPass(0, "1.0", "Success key Sent"); // teststep failed
              AssertPass("Success key Sent");
              
                 }
            else
            {
              DiagRequestSentError(ret, buffer);  
            }
  
    }
  
  SendInvalidkey_NoResponseCheck(){
    
      char buffer[100];
    byte Invalid_key[32]=0;
  long ret, ret2, ret3;
  dword keySizeOut;
      
    
         TestAction("Send request with Invalid key");
    //        write("Key is: 0x%02X%02X", key_s[0], key_s[1]);
            diagSetParameterRaw(keyReq, "Send_Key", Invalid_key, elCount(Invalid_key)); // Set the key in the request-object
            diagGetObjectName(keyReq, buffer, elCount(buffer));
            
            DiagSendRequest(keyReq); // Request security seed
 TestExpectation("Success in Sending request with Invalid key");
                  ret = testWaitForDiagRequestSent(keyReq, 2000); // Wait until the request has been completely sent
            if(ret==1) //Request sent
            {
                                        write("Success: Invalid key Sent");
              teststepPass(0, "1.0", "Success: Invalid key Sent"); // teststep failed
              AssertPass("Success: Invalid key Sent");
                 }
            else
            {
              DiagRequestSentError(ret, buffer);  
            }
    
    
    
  }
  
  IsDiff_seed(byte seed1[],byte seed2[],int size, char meaning[]){
    int flag=0;
        int i;
         TestAction(meaning);
   TestExpectation("Two seeds are Diffirent");
   
    

	for(i=0;i<size;i++){
		if(seed1[i]!=seed2[i]){
			      flag=1;                       
      break;
    }
    
	}
  if(flag==1){
         testStepPass(0, "1.0", "Succes: Seeds are different"); // teststep failed
      AssertPass("Succes: Seeds are different");
    
  }else{
    	 testStepFail(0, "1.0", "Fail: Seeds are same, Expected to be different"); // teststep failed
  AssertFail("Fail: Seeds are same, Expected to be different");
  }

  }
  
  Is_Not_Diff_seed(byte seed1[],byte seed2[],int size,char meaning[]){
  int flag=0;
        int i;
             TestAction("Check Two seeds are Same");
   TestExpectation("Two seeds are Same");
    

    
    
	for(i=0;i<size;i++){
		if(seed1[i]!=seed2[i]){
			      flag=1;                       
      break;
    }
    
	}
  if(flag==1){
              testStepFail(0, "1.0", "Fail: Seeds are different, Expected to be same"); // teststep failed
      AssertFail("Fail: Seeds are different, Expected to be same");
    
  }else{
	testStepPass(0, "1.0", "Success: Seeds are same "); // teststep failed
  AssertPass("Success: Seeds are same ");
  }
  
    
  }
  
    Is_seed_NotZeros(byte seed1[],int size){
    int flag=0;
        int i;
         TestAction("Check  seed not zeros");
   TestExpectation("seed not zeros");
   
    

	for(i=0;i<size;i++){
		if(seed1[i]==0){
			        flag++;                     
    }
	}
  if(flag==(size)){
        	 testStepFail(0, "1.0", "Fail: Seeds are  all 00s"); // teststep failed
  AssertFail("Fail: Seeds are Seeds are  all 00s");

  }else{
                     testStepPass(0, "1.0", "Succes: Seeds are not all 00s"); // teststep failed
      AssertPass("Succes: Seeds are not all 00s");
  }
  

  }
  
  void DiagRequestSentError(long ret, char buffer[])
{
  if(ret==0)
  {
    write("Timeout expired while trying to send request %s", buffer);
    testStepFail(0, "1.0", "Timeout expired while trying to send request %s", buffer);
    AssertFail("Timeout expired while trying to send request");
  }
  if(ret<0)
  {
    write("Internal error %d occured while trying to send request %s", ret, buffer);
    testStepFail(0, "1.0", "Internal error %d occured while trying to send request %s", ret, buffer);
    AssertFail("Internal error occured while trying to send request");
  }
}
  
  
  void DiagResponseError(long ret)
{
  if(ret==0) // Timeout. No response received
 {
    write("Timeout specified in TestWaitForDiagResponse expired");
    testStepFail(0, "1.0", "Timeout specified in TestWaitForDiagResponse expired");
  AssertFail("Timeout specified in TestWaitForDiagResponse expired");
  }
  if(ret<0) // Error e.g. transport protocol level
  {
    if(ret==-92) // This is the error code for P2 or P2* timeouts
    {
      write("TP level error %d, probably P2 or P2* timeout", ret); 
      testStepFail(0, "1.0", "TP level error %d, probably P2 or P2* timeout", ret);
      AssertFail("TP level error");
    }
    else
    {
      write("Error %d in the diagnostic or transport layer", ret); 
      testStepFail(0, "1.0", "Error %d in the diagnostic or transport layer", ret);
      AssertFail("Error  in the diagnostic or transport layer");
    }
  }
}



void UnlockSL01()
{

  char buffer[100];
  long ret, ret2, ret3, ret4;
  byte securitySeed[32], securityKey[4096];
  dword securityLevel=0x11;
 dword seedArraySize= 32;
  dword maxKeyArraySize = 4096;
  dword appTimeout_ms=20000;
  dword keySizeOut;
  
  testStep(0, "1.0", "Unlock security level 11"); // Write the current teststep to the testreport
  
  diagGetObjectName(seedReq, buffer, elCount(buffer)); // Get the name of the diagnostic object
  DiagSendRequest(seedReq); // Send request security seed
  ret = testWaitForDiagRequestSent(seedReq, 2000); // Wait until the request has been completely sent
  if(ret==1) // Request sent
  {
     TestReportWriteDiagObject(seedReq); // Write the request-Object to the testreport
     write("Request %s has been successfully sent", buffer);
     ret2=TestWaitForDiagResponse(seedReq, 5000); // Wait for a response, here for 5000ms. Note: This is no P2 timeout!
        
     if(ret2==1) // Response received
     {
        ret3=DiagGetLastResponseCode(seedReq); // Get the code of the receveived response
        if(ret3 == -1) // Positive response received
        {
          diagGetRespParameterRaw(seedReq, "Request_Seed", securitySeed, elCount(securitySeed)); // Retrieve the seed
          
            for(i=0;i<32;i++){
write("Seed: 0x%02X%", securitySeed[i]);
   
  }
          
          
          testReportWriteDiagResponse(seedReq); // Write the response to the testreport
          
          // Generate key from seed. Wait max 5000ms for the function in the DLL to return.
        //  ret4 = testWaitForGenerateKeyFromSeed( securitySeed, seedArraySize, securityLevel, securityKey, maxKeyArraySize,keySizeOut, appTimeout_ms);
            ret4 = testWaitForGenerateKeyFromSeed( "SWSP174",securitySeed, seedArraySize, securityLevel,"R2 Valeo","", securityKey, maxKeyArraySize, keySizeOut, appTimeout_ms); 
          testWaitForTimeout(4000);
            write("sec key size: %d", elCount(securityKey));
                          for(i=0;i<64;i++){
write("Key: 0x%02X%", securityKey[i]);
           
  }
                                        write("key count::: %d", elCount(securityKey));
              write("key size::: %d", keySizeOut);
            
          if(ret4==1) // Key generation successful
          {
            write("Key is: 0x%02X%02X", securityKey[0], securityKey[1]);
            diagSetParameterRaw(keyReq, "Send_Key", securityKey, elCount(securityKey)); // Set the key in the request-object
            diagGetObjectName(keyReq, buffer, elCount(buffer));
            
            DiagSendRequest(keyReq); // Request security seed
            ret = testWaitForDiagRequestSent(keyReq, 2000); // Wait until the request has been completely sent
            if(ret==1) //Request sent
            {
              TestReportWriteDiagObject(keyReq); // Write the request-Object to the testreport
              write("Request %s has been successfully sent", buffer);
              ret2=TestWaitForDiagResponse(keyReq, 5000); // Wait for a response, here for 5000ms. Note: This is no P2 timeout!  
              if(ret2 == 1) // Response received
              {
                ret3=DiagGetLastResponseCode(keyReq); // Get the code of the receveived response
                if(ret3 == -1) // Positive response received
                {
                  write("ECU unlocked for level 1");
                  testReportWriteDiagResponse(keyReq);
                  testStepPass(0, "1.0", "ECU unlocked for level 1");
                }
                else // Negative response received
                {
                  write("Negative Response upon Request %s, NRC: 0x%02X",buffer, (byte)ret3);
                  TestReportWriteDiagResponse(seedReq); // Write the response-Object to the testreport
                  testStepFail(0, "1.0", "Negative Response upon Request %s, NRC: 0x%02X",buffer, (byte)ret3); // teststep failed  
                }
              }
              else
              {
                DiagResponseError(ret2);  
              }
            }
            else
            {
              DiagRequestSentError(ret, buffer);  
            }
          }
          else
          {
            if(ret4==0)
            {
              write("Timeout during key generation");
              teststepfail(0, "1.0", "Timeout during key generation"); // teststep failed
            }
            else
            {
              write("Error code %d during key calculation",ret4);
              teststepfail(0, "1.0", "Error code %d during key calculation",ret4);
            }
          }
        }
        else // Negative response received
        {
          write("Negative Response upon Request %s, NRC: 0x%02X", buffer, (byte)ret3);
          TestReportWriteDiagResponse(seedReq); // Write the response-Object to the testreport
          testStepFail(0, "1.0", "Negative Response upon Request %s, NRC: 0x%02X", buffer, (byte)ret3); // teststep failed  
        }
     }
     else
     {
        DiagResponseError(ret2);
     }
   }
   else
   {
      DiagRequestSentError(ret, buffer);
   }       
}

void UnlockSL03()
{
  long ret;
  
  testStep(0, "2.0", "Unlock security level 3"); // Write the current teststep to the testreport

  // Connect the internal diagnostics channel
  // (alternatively, this could be done by simply sending a diagnostics request)
  ret = diagConnectChannel("SWSP174");
  if(ret == 0)
    write("Internal diagnostic channel is connected");
  else
  {
    write("Error %d when trying to connect internal diagnostic channel", ret);
  }
  
  ret = testWaitForUnlockEcu("SWSP174", 17); // Unlock security level 3
  
  if(ret == 0) // Security level has been unlocked successfully
  {
    write("ECU unlocked for level 3");
    testStepPass(0, "2.0", "ECU unlocked for level 3");
  }
  else // Some error occured when trying to unlock the security level
  {
    write("Error code %d during key calculation",ret);
    teststepfail(0, "2.0", "Error code %d during unlocking ECU",ret);  
  }
}
void Set_Signal_PN14_SupBat(double volt)
{
  char str[200]=0;
  snprintf(str, elcount(str),"Set Signal: PN14_SupBat_Volt_ST3 : %f ",volt);
   setSignalwithValue(PN14_SupBat_Volt_ST3,volt,str);
}

void Set_Signal_VehSp_Stat_ST3(int state)
{
  char str[200]=0;
  snprintf(str, elcount(str),"Set Signal: VehSp_Stat_ST3 : %f ",state);
   setSignalwithValue(VehSp_Stat_ST3,state,str);
}


void Change_Variant(char Variant[])
{int ret=0;
ret=testWaitForDiagChangedActiveVariant(Variant);
  if(1==ret){
    testStepPass( "Variant changed sucessfully to %s",Variant); 
    
  }else{
       teststepfail("", "Error code %d during Changing ECU Variant to %s",ret,Variant); 
  }
}


Can_Bus_failure(void){
  
    Control_ShortCutCANL(CanL_Short_to_Vbat,Can_Activate_ON);
  testWait(20000);
 
    Control_ShortCutCANL(CanL_Short_to_Vbat,Can_Activate_OFF);
  testWait(10000);
  
}


void compare_strings(char str[],char str2[],long sizeOfcompare){
  int flag=1;
  char result[400]=0;
  byte Hex_str1[400]=0;
  byte Hex_str2[400]=0;
  flag=1;
  Convert_String_To_Hex(str,Hex_str1);
  Convert_String_To_Hex(str2,Hex_str2);
    for ( i = 0 ;i<(sizeOfcompare); i++)
      {

        if(Hex_str1[i]!=Hex_str2[i]){
            flag = 0;
          write( "NOT Eq %d hex1  %x  hex1  %x",i,Hex_str1[i],Hex_str2[i]);
        }
   write( "%d hex1  %x  hex1  %x",i,Hex_str1[i],Hex_str2[i]);        
        write( " %d Flag   %d",i,flag);
      }
      if(flag==0){
          
          strncat(result,str,4000);
          strncat(result," not equal ",4000);
          strncat(result,str2,4000);
          testStepFail(result);
          AssertFail(result);
      }
      else
      {
        
        snprintf(result,400,"Both strings are equal :%s",str);
        testStepPass(result);
        AssertPass(result);
      }
  result[0]='\0';
      flag=1;
}
