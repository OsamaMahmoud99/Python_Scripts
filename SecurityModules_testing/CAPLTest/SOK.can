/*@!Encoding:65001*/
includes
{
  
  #include "Generics\Generics_CAN_Functions.cin"
  #include "Generics\Generics_TestCase.cin"
  #include "Generics\Generics_DiagSupportFunctions.cin"
  #include "Generics\Generics_Diag.cin"
}

variables
{
  
  long retVal;
  long status = 1; 
  char flag = 0;

  byte RequestDownload_usedDLC[187]={0x31, 0x01, 0xC0, 0x0A,0x00,0x01,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x00,0x01,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x05,0x05,0x05,0x00,0x06,0xEA,0x34,0x3A,0x3B,0xBB,0xC1,0xA8,0x8C,0x62,0xC2,0x1D,0x7C,0x80,0x85,0x92,0x37,0x04,0x53,0xE3,0xAC,0x67,0x99,0x5A,0xD1,0xB3,0x34,0x5B,0x4A,0x4F,0x9B,0x27,0xF7,0xE5,0xCF,0xD6,0xA1,0xFD,0x59,0x9D,0xB1,0x59,0x22,0xB0,0x30,0x59,0x13,0xEF,0x76,0x9E,0x05,0x5F,0x3A,0x7D,0xD0,0xDB,0x84,0x3D,0xAA,0xAD,0x07,0x8D,0xE6,0xF6,0x72,0x79,0x21,0x03,0x1F,0xD7,0x6C,0xF7,0xCC,0x3C,0x91,0xF9,0x79,0x57,0xE2,0xF4,0x02,0x7A,0x3B,0x1B,0x7A,0x2C,0x8C,0x52,0x92,0x39,0x20,0xC2,0x1F,0xC6,0xD0,0x6B,0x1D,0xE2,0x31,0xC1,0x8E,0x57,0x65,0xA3,0xCE,0x16,0x5E,0xED,0x25,0xBA,0x97,0x79,0xF8,0xF5,0x09,0xD7,0xC5,0xEC,0x41,0x2C,0x45,0x34,0x4C,0x29,0x9D,0x46,0xF2,0x01,0xDE,0xFB,0xD0,0x85,0x64,0x34,0xC4,0x7A,0x9F,0x34,0x18,0x22,0x87,0x44,0x30,0xDA,0xFA,0x17};
  byte RequestDownload_resetDLC[115]={0x31, 0x01, 0xC0, 0x0A,0x00,0x01,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xA5,0xDB,0x3F,0xD0,0xAB,0x5F,0x2F,0x31,0xE2,0x9F,0x1B,0x6A,0xE4,0x67,0x40,0x84,0x01,0xEA,0x33,0x3A,0xC1,0xC5,0x32,0xA6,0x6C,0x61,0x74,0x3C,0x12,0x9D,0x78,0xA6,0xB1,0xB5,0x6E,0xAE,0x32,0x11,0x06,0x87,0x11,0x83,0x6E,0x17,0xD4,0x62,0x3D,0xE2,0x74,0xFF,0x09,0x71,0xEA,0xA6,0xFD,0x59,0x24,0x98,0x77,0x9F,0xAD,0x86,0x1E,0x63,0x75,0xD7,0xBA,0x99,0x3B,0x60,0x0C,0x4D,0xCB};
  
  //wrong keys for SOK time, central locking and door pdus
  byte RequestDownload_usedDLC_with_wrong_keys[187]={0x31,0x01,0xC0,0x0A,0x00,0x01,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x00,0x01,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x05,0x05,0x05,0x00,0x06,0xCF,0xC9,0xFB,0x3E,0xFE,0xA2,0x80,0x9B,0x2B,0x17,0x5D,0x23,0x9B,0x16,0x8D,0xA4,0x04,0x53,0xE3,0xAC,0x67,0x99,0x5A,0xD1,0xB3,0x34,0x5B,0x4A,0x4F,0x9B,0x27,0xF7,0xE5,0xCF,0xD6,0xA1,0xFD,0x59,0x9D,0xB1,0x59,0x22,0xB0,0x30,0x59,0x13,0xEF,0x76,0x9E,0x05,0x5F,0x3A,0x7D,0xD0,0xDB,0x84,0x3D,0xAA,0xAD,0x07,0x8D,0xE6,0xF6,0x72,0x79,0x21,0x03,0x1F,0xD7,0x6C,0xF7,0xCC,0x3C,0x91,0xF9,0x79,0x57,0xE2,0xF4,0x02,0x7D,0x3B,0x1B,0x7A,0x2C,0x8C,0x52,0x92,0x39,0x20,0xC2,0x1F,0xC6,0xD0,0x6B,0x1D,0xE2,0x31,0xC1,0x8E,0x57,0x65,0xA3,0xCE,0x1D,0x5E,0xED,0x25,0xBA,0x97,0x79,0xF8,0xF5,0x09,0xD7,0xC5,0xEC,0x41,0x2C,0x45,0x34,0x4C,0x29,0x9D,0x46,0xF2,0x01,0xDE,0xF0,0xA5,0xC1,0xA5,0x57,0x16,0x03,0xD1,0x8E,0xF9,0x2D,0x8A,0x97,0x4C,0xAB,0x04,0x2C};
  int requestDownload_result = 0x24;
  int requestDownload_wrongMac_result = 0x1E;  //VKMS_ERR_DLC_INVALID_MAC
  
 
  byte PSS_Hash_ResetDLC_Expected[22] = {0x71, 0x03, 0xC0, 0x0D, 0x24, 0x00,0x14,0x85,0x52,0xB5,0x87,0x93,0xB4,0xE3,0x58,0xF4,0xD1,0xD1,0xB9,0x26,0x9C,0xC9};
  byte PSS_Hash_UsedDLC_Expected[22] = {0x71, 0x03, 0xC0, 0x0D, 0x24, 0x00,0xF7,0xF8,0xCA,0x16,0xD6,0xB6,0x98,0x0C,0x13,0xFC,0xE4,0x2E,0x30,0x48,0xE5,0x66};


  
  int error_value = 23;     //VKMS busy

  int j=0;
  int wrong_gmac = 0;
  int correct_gmac = 1;
  int correct_gmac_wrong_keys = 2;
  
  dword timeout_1000_ms=1000;
  dword timeout_2000_ms=2000;
  dword timeout_5000_ms=5000;
  dword timeout_10000_ms = 10000;
  dword timeout_20000_ms = 20000;
  dword timeout_6000_ms = 6000;
  dword timeout_50_ms = 50;
  dword timeout_100_ms = 100;
  
  int VKMS_ERR_DLC_MISSING_KEY = 36;
  int VKMS_ERR_BUSY = 23;
  int VKMS_ERR_DLC_VERIFICATION_MISMATCH = 33;
  int VKMS_ERR_DLC_DEPRECATED = 32;
  int VKMS_ERR_DLC_INVALID_MAC = 30;
   
  
  byte SOK_verification_failed_list[2] = {0x01 , 0x8B};
  byte SOK_signature_failed_list[2] = {0x01 , 0x8F};
  byte SOK_general_information[2] = {0x01 , 0x90};
  byte SOK_time_information[2] = {0x01 , 0x91};
  byte SOK_freshness_information[2] = {0x01 , 0x92};
  byte SOK_missing_key_list[2] = {0x01 , 0x94};
  
 
  byte SOK_Participant = 0x01;
  int IsValidTime;
  byte ValidTime_byte = 4;
  int IsJitterExceeded;
  byte Jitter_byte = 13;
  byte freshness_byte = 3;
  int IsfreshnessValid; 
  int IsSecOCValid;
  byte Signaturegenerationfailed_DTC[3] = {0x05,0x00,0x03};
  byte Signatureverificationfailed_DTC[3] = {0x05,0x00,0x02};
  byte Timenotavailable_DTC[3] = {0x05,0x00,0x01};
  byte VKMSSOKkeynotavailable_DTC[3] = {0x05,0x00,0x04};
  
  int NoAuthenticTime_Counter=0;
  byte Current_Time[8];
  byte Current_Time_2[8];
  byte Freshness_Current_Time[47];
  int freshness_flag = 0;
  int product_name;
  int pdu_length;
  dword STARTUP_TIME = 2000;
  int chal_pdu_length = 0;
  int FirstByte_AuthenticPDU;
  int Time_flag;
  int Time_flag_2;
  int Time_buffer;
  int flag_2=0;
  int Freshness_AuthenticPDU[7];
  int k = 32;
  qword test=0;
  qword result_qword;
  qword freshness;
  byte freshness_array[8];
  char freshness_string[362];
  dword freshness_len = 8;
  int counter=0;
}
  


void Download_ResetDLC()
{
      error_value = VKMS_ERR_BUSY;

      /* Download used DLC*/
      sendDiagnosticsRequest_array(RequestDownload_resetDLC , 115);
      
      snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0A");
      checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
  
      while(error_value == VKMS_ERR_BUSY)
      {
          /* check result is equal to 24: 31 03 C0 0A - TABROW_VkmsHandlDownl_Results */
          snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0A");
          sendDiagnosticsRequest(BufferString , "check result");
        
    
          snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0A 0x%02X 0x%02X",0x24,0x00);
          error_value = checkDiagnosticsResponse_returnValue(BufferString,timeout_1000_ms, "Check positive response for requestDownload_result");
         testWaitForTimeout(100);
         
       
      }
      if(error_value == VKMS_ERR_DLC_VERIFICATION_MISMATCH)
      {
        testStepFail("The calculated DLC-verificationchecksum is not consistent with the expected value inside the DLC"); 
      }
      else if(error_value == 0x20)
      {
        testStepFail("The value of the ECU learning counter in the DLC is less than the saved value");
      }
      else if(error_value == 0)
      {
        testStepPass("Operation successful:Expected result was equal to actual");
      }
}

void Download_UsedDLC(int gmac_status)
{
  
  error_value = VKMS_ERR_BUSY;

  if(gmac_status == correct_gmac)
  {
      sendDiagnosticsRequest_array(RequestDownload_usedDLC , 187);
  }
  
  if(gmac_status == correct_gmac_wrong_keys)
  {
      sendDiagnosticsRequest_array(RequestDownload_usedDLC_with_wrong_keys , 187);
  }
  
  snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0A");
  checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");

  while(error_value == VKMS_ERR_BUSY)
  {
     /* check result is equal to 24: 31 03 C0 0A - TABROW_VkmsHandlDownl_Results */
    snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0A");
    sendDiagnosticsRequest(BufferString , "check result");
    
    snprintf(BufferString, 100, "0x71 0x03 0xC0 0x0A 0x%02X 0x%02X",requestDownload_result,0x00);
    error_value = checkDiagnosticsResponse_returnValue(BufferString,timeout_1000_ms, "Check positive response for requestDownload_result");
    testWaitForTimeout(100);
    
  }
  if(error_value == VKMS_ERR_DLC_VERIFICATION_MISMATCH)
  {
      testStepFail("The calculated DLC-verificationchecksum is not consistent with the expected value inside the DLC"); 
  }
  else if(error_value == 0){
      testStepPass("Expected result was equal to actual");
  }

 
}


void Start_ExtendedSession()
{
  snprintf(BufferString, 100, "0x10 0x03");
  sendDiagnosticsRequest(BufferString , "start extended session");
  
   
  snprintf(BufferString, 100, "0x50 0x03 0x00 0x32 0x01 0xF4");
  checkDiagnosticsResponse(BufferString , 1000, "check positive response for start extended session");
}

int Get_PssHash_UsedDLC()
{
  /* start get pss hash */
  snprintf(BufferString, 100, "0x31 0x01 0xC0 0x0D 0x00");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0D");
  checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
  
  testWaitForTimeout(100);
  snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0D");
  sendDiagnosticsRequest(BufferString , "check result");
  
  /* Check positive response for pss Hash */
  error_value = checkDiagnosticsResponse_array_returnError(PSS_Hash_UsedDLC_Expected,22,1000, "Check positive response for pss Hash");  
    return error_value;

}

int Get_PssHash_ResetDLC()
{
  snprintf(BufferString, 100, "0x31 0x01 0xC0 0x0D 0x00");
  sendDiagnosticsRequest(BufferString , "send start pss hash request ");
  
  snprintf(BufferString, 100, "0x71 0x01 0xC0 0x0D");
  checkDiagnosticsResponse(BufferString,timeout_2000_ms, "Check positive response for request");
  testWaitForTimeout(100);
  snprintf(BufferString, 100, "0x31 0x03 0xC0 0x0D");
  sendDiagnosticsRequest(BufferString , "check result");
  
  /* Check positive response for pss Hash */
  error_value = checkDiagnosticsResponse_array_returnError(PSS_Hash_ResetDLC_Expected,22,1000, "Check positive response for pss Hash");  

  write("error pss hash value is %d",error_value);
  return error_value;
}

on PDU DoorFunctions_BFS_01_XIX_HCP4_CANFD01_E2E
{
  if(this.ValidationFlags==3)  
  {
    write("SecOC validation of Door BFS PDU is successfull");
    sysSetVariableInt(sysvar::SecOC_Valid , 1);
    sysSetVariableInt(sysvar::Door_pdu_length , this.PduLength);
    
    if(Time_flag_2 == 1)
    {
      Time_flag_2 = 2; 
    }
    
  }
  else if(this.ValidationFlags==1)
  {
    write("SecOC validation of Door BFS PDU is failed");
    sysSetVariableInt(sysvar::SecOC_Valid , 0);
  }
  else
  {
    write("internal module error");
    sysSetVariableInt(sysvar::SecOC_Valid , 0);
  }
}
on PDU DoorFunctions_FS_01_XIX_HCP4_CANFD01_E2E
{
  if(this.ValidationFlags==3)  
  {
    write("SecOC validation of Door FS PDU is successfull");
    sysSetVariableInt(sysvar::SecOC_Valid , 1);
    sysSetVariableInt(sysvar::Door_pdu_length , this.PduLength);
    
    if(Time_flag_2 == 1)
    {
      Time_flag_2 = 2; 
    }
  }
  else if(this.ValidationFlags==1)
  {
    write("SecOC validation of Door FS PDU is failed");
    sysSetVariableInt(sysvar::SecOC_Valid , 0);
  }
  else
  {
    write("internal module error");
    sysSetVariableInt(sysvar::SecOC_Valid , 0);
  }
}

on PDU DoorFunctions_HBFS_01_XIX_HCP4_CANFD01_E2E
{
  if(this.ValidationFlags==3)  
  {
    write("SecOC validation of Door HBFS PDU is successfull");
    sysSetVariableInt(sysvar::SecOC_Valid , 1);
    sysSetVariableInt(sysvar::Door_pdu_length , this.PduLength);
    
    if(Time_flag_2 == 1)
    {
      Time_flag_2 = 2; 
    }
  }
  else if(this.ValidationFlags==1)
  {
    write("SecOC validation of Door HBFS PDU is failed");
    sysSetVariableInt(sysvar::SecOC_Valid , 0);
  }
  else
  {
    write("internal module error");
    sysSetVariableInt(sysvar::SecOC_Valid , 0);
  }
}

on PDU DoorFunctions_HFS_01_XIX_HCP4_CANFD01_E2E
{
  if(this.ValidationFlags==3)  
  {
    write("SecOC validation of Door HFS PDU is successfull");
    sysSetVariableInt(sysvar::SecOC_Valid , 1);
    sysSetVariableInt(sysvar::Door_pdu_length , this.PduLength);
    if(Time_flag_2 == 1)
    {
      Time_flag_2 = 2; 
    }
  }
  else if(this.ValidationFlags==1)
  {
    write("SecOC validation of Door HFS PDU is failed");
    sysSetVariableInt(sysvar::SecOC_Valid , 0);
  }
  else
  {
    write("internal module error");
    sysSetVariableInt(sysvar::SecOC_Valid , 0);
  }
}


testcase SOK_TC_1()
{
  /********************** Precondition *************************/
  Start_ExtendedSession();
  
  /******************** Action ***************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  testWaitForTimeout(timeout_1000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_1000_ms);
  

}

testcase SOK_TC_2()
{
  counter=0;
  /********************** Precondition *************************/
  Start_ExtendedSession();
  
  /******************** Action ***************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  Download_UsedDLC(correct_gmac_wrong_keys);  
  testWaitForTimeout(10000);

  sendDiagnosticsRequest("0x14 0xFF 0xFF 0xFF","clear All DTC");
  checkDiagnosticsResponse("0x54",timeout_1000_ms,"check positive response for clear All DTCs");
  Pause(5000 , "wait for Clear DTCs");
  
  testWaitForTimeout(10000);

    /* restart ECU to set DTC confirmed bit */ 
  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x51 0x02");
  checkDiagnosticsResponse(BufferString,5000, "Check positive response");
  
  testWaitForTimeout(10000);
  
  /* Read DID SOK_verification_failed_list with failed DID*/
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X",SOK_verification_failed_list[0],SOK_verification_failed_list[1]);
  sendDiagnosticsRequest(BufferString , "Read DID SOK_verification_failed_list");
  
  snprintf(BufferString, 100, "0x62 0x01 0x8B 0x00 0x02 0x01 0x81 0x02 0x59");
  checkDiagnosticsResponse(BufferString,1000, "Check positive response for SOK_verification_failed_list with PDU 0x259 marked as failed");
}

testcase SOK_TC_3()
{
  
  /********************** Precondition *************************/
  Start_ExtendedSession();
  
  /******************** Action ***************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  /* restart ECU to set DTC confirmed bit */ 
  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x51 0x02");
  checkDiagnosticsResponse(BufferString,5000, "Check positive response");
    Start_ExtendedSession();

  testWaitForTimeout(10000);
  /* Read DID SOK_signature_failed_list */
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X",SOK_signature_failed_list[0],SOK_signature_failed_list[1]);
  sendDiagnosticsRequest(BufferString , "Read DID SOK_signature_failed_list");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X 0x%02X 0x%02X 0x02 0x0F",SOK_signature_failed_list[0],SOK_signature_failed_list[1],0x00,0x01);
  checkDiagnosticsResponse(BufferString,1000, "Check positive response for SOK_signature_failed_list");
  
  Download_UsedDLC(correct_gmac);
  testWaitForTimeout(1000);
  /* restart ECU to set DTC confirmed bit */ 
  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x51 0x02");
  checkDiagnosticsResponse(BufferString,5000, "Check positive response");
  
  testWaitForTimeout(15000);
  
   /* Read DID SOK_signature_failed_list */
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X",SOK_signature_failed_list[0],SOK_signature_failed_list[1]);
  sendDiagnosticsRequest(BufferString , "Read DID SOK_signature_failed_list");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X 0x%02X 0x%02X",SOK_signature_failed_list[0],SOK_signature_failed_list[1],0x00,0x00);
  checkDiagnosticsResponse(BufferString,1000, "Check positive response for SOK_signature_failed_list");
}

testcase SOK_TC_4()
{
  /********************** Precondition *************************/
  Start_ExtendedSession();
  
  /******************** Action ***************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  testWaitForTimeout(timeout_1000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_1000_ms);
  
  /* Read DID SOK_general_information */
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X",SOK_general_information[0],SOK_general_information[1]);
  sendDiagnosticsRequest(BufferString , "Read DID SOK_general_information");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X",SOK_general_information[0],SOK_general_information[1],0x00,SOK_Participant,0x05);
  checkDiagnosticsResponse(BufferString,1000, "Check positive response for SOK_general_information");
  
}

on PDU SOK_NoAuthenticTime_01_XIX_HCP4_CANFD01
{
   if(Time_flag == 1){
    //put data in buffer
     FirstByte_AuthenticPDU = this.byte(1);
     write("FirstByte_AuthenticPDU : %d",FirstByte_AuthenticPDU);
     Time_flag=2;
    }
}


testcase SOK_TC_5()
{
  /********************** Precondition *************************/
  Start_ExtendedSession();
  
  /******************** Action ***************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  testWaitForTimeout(timeout_1000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_1000_ms);

  Time_flag = 1;
  while(Time_flag != 2){testWaitForTimeout(500);
  testStep("","PDU not recieved!");}
 
    
    /* Read DID SOK_time_information */
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X",SOK_time_information[0],SOK_time_information[1]);
  sendDiagnosticsRequest(BufferString , "Read DID SOK_time_information");
      
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X %s",SOK_time_information[0],SOK_time_information[1],"Check positive response for SOK_time_information");
  TestExpectation(BufferString);
  SOK_checkDiagnosticsResponse_returnArray(Current_Time,14, 6 ,12 , 1000);
      
  /*for(i=0; i<7; i++)
  {
    write("Current_Time: %d",Current_Time[i]);    
  }*/
      
  
    
    if( (Current_Time[6] - FirstByte_AuthenticPDU) <= 10)
    {
      testStepPass("Current between time DID and time in NoAuthentic PDU is less than 100ms");
    }
    else
    {
      testStepFail("Current between time DID and time in NoAuthentic PDU is bigger than 100ms");
    }
  
    testWaitForTimeout(timeout_1000_ms);
    
  /* Read DID SOK_time_information */
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X",SOK_time_information[0],SOK_time_information[1]);
  sendDiagnosticsRequest(BufferString , "Read DID SOK_time_information");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X %s",SOK_time_information[0],SOK_time_information[1],"Check positive response for SOK_time_information");
  TestExpectation(BufferString);
  IsValidTime = SOK_checkDiagnosticsResponse_returnValue(ValidTime_byte,14,1000);
  

  
  if(IsValidTime == 0x00)
  {
      testStepPass("ValidTime his is refer to valid used DLC"); 
    
      snprintf(BufferString, 100, "0x22 0x%02X 0x%02X",SOK_time_information[0],SOK_time_information[1]);
      sendDiagnosticsRequest(BufferString , "Read DID SOK_time_information");
  
      snprintf(BufferString, 100, "0x62 0x%02X 0x%02X %s",SOK_time_information[0],SOK_time_information[1],"Check positive response for SOK_time_information");
      TestExpectation(BufferString);
    
      IsJitterExceeded = SOK_checkDiagnosticsResponse_returnValue(Jitter_byte,14,1000);
  
      if(IsJitterExceeded == 0x00)
      {
        testStepPass("Jitter Not Exceeded this is refer to valid used DLC"); 
      }
      else
      {
        testStepFail("Jitter Exceeded This is refer to Used DLC not downloaded yet");
      }
  }
  else
  {
    testStepFail("WrongTime This is refer to Notvalid Used DLC");
  }
  

}

testcase SOK_TC_6()
{
  int variant;
  int prod;
  /********************** Precondition *************************/
  Start_ExtendedSession();
  variant = sysGetVariableInt(sysvar::Variant);
  prod = sysGetVariableInt(sysvar::product);
  
  /******************** Action ***************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  testWaitForTimeout(timeout_1000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_1000_ms);
  
  Time_flag = 1;
  while(Time_flag != 2){testWaitForTimeout(500);
  testStep("","PDU not recieved!");}
  
   /* Read DID SOK_freshness_information */
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X",SOK_freshness_information[0],SOK_freshness_information[1]);
  sendDiagnosticsRequest(BufferString , "Read DID SOK_freshness_information");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X %s",SOK_time_information[0],SOK_time_information[1],"Check positive response for SOK_freshness_information");
  TestExpectation(BufferString);
  
  
  if(prod == Audi)
  {
    SOK_checkDiagnosticsResponse_returnArray(Freshness_Current_Time,47, 0 ,46 , 1000);
    if(Freshness_Current_Time[4] == 0x03)
    {
      testStepPass("The number of Pdus is 3");
    }
    else
    {
      testStepFail("The number of Pdus is not equal 3");
    }
  }
  else if(prod == VW)
  {
    SOK_checkDiagnosticsResponse_returnArray(Freshness_Current_Time,33, 0 ,32 , 1000);
    if(Freshness_Current_Time[4] == 0x02)
    {
      testStepPass("The number of Pdus is 2");
    }
    else
    {
      testStepFail("The number of Pdus is not equal 2"); 
    }
    write("Freshness_Current_Time: %d %d %d %d" , Freshness_Current_Time[0],Freshness_Current_Time[1],Freshness_Current_Time[2],Freshness_Current_Time[3]);
  }
  
  
  if( (prod == Audi && variant == variant_FS) || (prod == VW && variant == variant_FS))
  {
    if(Freshness_Current_Time[5] == 0x01 && Freshness_Current_Time[6]==0x81)
    {
      testStepPass("Valid Id for challenge PDU");
    }
    else
    {
      testStepFail("Wrong Id for challenge PDU");
    }
  
  }
  else if( (prod == Audi && variant == variant_BFS) || (prod == VW && variant == variant_BFS) )
  {
    if(Freshness_Current_Time[5] == 0x01 && Freshness_Current_Time[6]==0x82)
    {
      testStepPass("Valid Id for challenge PDU");
    }
    else
    {
      testStepFail("Wrong Id for challenge PDU");
    }
  }
  if(Freshness_Current_Time[19] == 0x02 && Freshness_Current_Time[20]==0x59)
  {
    testStepPass("Valid Id for NOAuthentic Time PDU");
    
    write("Freshness_Current_Time:%d",Freshness_Current_Time[29]);
    if( (Freshness_Current_Time[29] - FirstByte_AuthenticPDU) <= 10)
    {
      testStepPass("Current between time DID and time in NoAuthentic PDU is less than 100ms");
    }
    else
    {
      testStepFail("Current between time DID and time in NoAuthentic PDU is bigger than 100ms");
    }
  
  }
  else
  {
    testStepFail("Wrong Id for NOAuthentic Time PDU");
  }
  
  if(prod == Audi && variant == variant_FS)
  {
    if(Freshness_Current_Time[33] == 0x02 && Freshness_Current_Time[34]==0x0F)
    {
      testStepPass("Valid Id for Door PDU");
    }
    else
    {
      testStepFail("Wrong Id for Door PDU");
    }
  }
  else if(prod == Audi && variant == variant_BFS)
  {
    if(Freshness_Current_Time[33] == 0x02 && Freshness_Current_Time[34]==0x10)
    {
      testStepPass("Valid Id for Door PDU");
    }
    else
    {
      testStepFail("Wrong Id for Door PDU");
    }
  }
}

testcase SOK_TC_7()
{
  /********************** Precondition *************************/
  Start_ExtendedSession();
  
  /******************** Action ***************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  testWaitForTimeout(timeout_1000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_1000_ms);
  
  
  /* Read DID SOK_missing_key_list */
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X",SOK_missing_key_list[0],SOK_missing_key_list[1]);
  sendDiagnosticsRequest(BufferString , "Read DID SOK_missing_key_list");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X 0x%02X 0x%02X",SOK_missing_key_list[0],SOK_missing_key_list[1],0x00,0x00);
  checkDiagnosticsResponse(BufferString,1000, "Check positive response for SOK_missing_key_list");
  
}

                           
testcase SOK_TC_8()
{
  /********************** Precondition *************************/
  Start_ExtendedSession();
  
  /******************** Action ***************************/
 if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
 }
  
  testWaitForTimeout(timeout_1000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_1000_ms);
  
  chal_pdu_length = 0;
  
  /* restart ECU */ 
  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x51 0x02");
  checkDiagnosticsResponse(BufferString,5000, "Check positive response");
  
  testWaitForTimeout(STARTUP_TIME);
  
  chal_pdu_length = sysGetVariableInt(sysvar::challenge_pdu_length);
  if(chal_pdu_length == 8)
  {
    testStepPass("ECU send challenge successfully");
  }
  else
  {
    testStepFail("ECU Failed to send challenge");
  } 
}

testcase SOK_TC_9()
{
  int variant;
  /********************** Precondition *************************/
  Start_ExtendedSession();
  
  /******************** Action ***************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  testWaitForTimeout(timeout_1000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  testWaitForTimeout(timeout_1000_ms);
  
  product_name = sysGetVariableInt(sysvar::product);
  variant = sysGetVariableInt(sysvar::Variant);
  if(product_name == Audi)
  {
      IsSecOCValid = sysGetVariableInt(sysvar::SecOC_Valid);
      
      if(IsSecOCValid == 1)
      {
        testStepPass("SecOC validation of Door PDU is successfull");
      }
      else
      {
        testStepFail("SecOC validation of Door PDU is failed");
      }
      
      pdu_length = sysGetVariableInt(sysvar::Door_pdu_length);
      write("pdu_length is %d",pdu_length);
      
      if(variant == variant_FS)
      {
        if(pdu_length  == 64)
        {
          testStepPass("The length of the payload data as well as the signature are as defined in the  SOK-DFL resp 64 byte");
        }
        else
        {
          testStepFail("The length of the payload data not equal to the defined in the  SOK-DFL resp");
        }
      }
      else if(variant == variant_BFS)
      {
        if(pdu_length  == 48)
        {
          testStepPass("The length of the payload data as well as the signature are as defined in the  SOK-DFL resp 48 byte");
        }
        else
        {
          testStepFail("The length of the payload data not equal to the defined in the  SOK-DFL resp");
        }
      }
  }
  
  sendDiagnosticsRequest("0x14 0xFF 0xFF 0xFF","clear All DTC");
  
  checkDiagnosticsResponse("0x54",timeout_1000_ms,"check positive response for clear All DTCs");
  Pause(2000 , "wait for Clear DTCs");
  

  sendDiagnosticsRequest("0x19 0x02 0x2F","Read DTCs wih mask 0x2F");
  checkDTCObtained_withMask_2(Signaturegenerationfailed_DTC,0x2F, 1000, "check DTC is not failed");
  
  sendDiagnosticsRequest("0x19 0x02 0x2F","Read DTCs wih mask 0x2F");
  checkDTCObtained_withMask_2(Signatureverificationfailed_DTC,0x2F, 1000, "check DTC is not failed");
  
  sendDiagnosticsRequest("0x19 0x02 0x2F","Read DTCs wih mask 0x2F");
  checkDTCObtained_withMask_2(Timenotavailable_DTC,0x2F, 1000, "check DTC is not failed");
}

testcase SOK_TC_9_negative()
{
  int variant;
  /********************** Precondition *************************/
  Start_ExtendedSession();
  
  /******************** Action ***************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  if(Get_PssHash_UsedDLC() == 0){
    Download_UsedDLC(correct_gmac);
  }
  testWaitForTimeout(1000);
  sendDiagnosticsRequest("0x14 0xFF 0xFF 0xFF","clear All DTC");
  checkDiagnosticsResponse("0x54",timeout_1000_ms,"check positive response for clear All DTCs");
  testWaitForTimeout(1000);
  Download_ResetDLC();
  testWaitForTimeout(10000);

  snprintf(BufferString, 100, "0x11 0x02");
  sendDiagnosticsRequest(BufferString , "check result");
  
  snprintf(BufferString, 100, "0x51 0x02");
  sysSetVariableInt(sysvar::SecOC_Valid , 0);

  testWaitForTimeout(10000);
  
  product_name = sysGetVariableInt(sysvar::product);
  variant = sysGetVariableInt(sysvar::Variant);
  if(product_name == Audi)
  {
      IsSecOCValid = sysGetVariableInt(sysvar::SecOC_Valid);
      
      if(IsSecOCValid == 0)
      {
        testStepPass("SecOC validation of Door PDU is failed");
      }
      else
      {
        testStepFail("SecOC validation of Door PDU is successfull");
      }
      
      pdu_length = sysGetVariableInt(sysvar::Door_pdu_length);
      write("pdu_length is %d",pdu_length);
      
       if(variant == variant_FS)
      {
        if(pdu_length  == 64)
        {
          testStepPass("The length of the payload data as well as the signature are as defined in the  SOK-DFL resp 64 byte");
        }
        else
        {
          testStepFail("The length of the payload data not equal to the defined in the  SOK-DFL resp");
        }
      }
      else if(variant == variant_BFS)
      {
        if(pdu_length  == 48)
        {
          testStepPass("The length of the payload data as well as the signature are as defined in the  SOK-DFL resp 48 byte");
        }
        else
        {
          testStepFail("The length of the payload data not equal to the defined in the  SOK-DFL resp");
        }
      }
  }
}

testcase SOK_TC_10()
{
  
  /********************** Precondition *************************/
  Start_ExtendedSession();
  product_name = sysGetVariableInt(sysvar::product);
  
  /******************** Action ***************************/
  if(Get_PssHash_ResetDLC() == 0){
    Download_ResetDLC();
  }
  
  testWaitForTimeout(timeout_1000_ms);
  
  Download_UsedDLC(correct_gmac);
  
  if(product_name == Audi)
  {
          
    /*Wait for the ECU to sent a broadcast I-PDU according to the SOK-DFL*/
    Time_flag_2 = 1;
    while(Time_flag_2 != 2){testWaitForTimeout(500);
    testStep("","PDU not recieved!");}
  }
  testWaitForTimeout(500);
  
  /* Read DID SOK_time_information */
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X",SOK_time_information[0],SOK_time_information[1]);
  sendDiagnosticsRequest(BufferString , "Read DID SOK_time_information");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X %s",SOK_time_information[0],SOK_time_information[1],"Check positive response for SOK_time_information");
  TestExpectation(BufferString);
  SOK_checkDiagnosticsResponse_returnArray(Current_Time,14, 6 ,12 , 1000);
  
  
  if(product_name == Audi)
  {
          
    /*Wait for the ECU to sent a broadcast I-PDU according to the SOK-DFL*/
    sysSetVariableInt(sysvar::Time_flag_2 , 1);
    while(sysGetVariableInt(sysvar::Time_flag_2) != 2){testWaitForTimeout(500);
    testStep("","PDU not recieved!");}
    
    // Initialize the qword value to 0
    result_qword = 0;

    // Combine the bytes into the qword value
    for (i = 0; i < 6; ++i)
    {
        result_qword |= ((qword)Current_Time[i]) << (i * 8);
    }
    
    write("fressssssssss is %llu",sysGetVariableQWord(sysvar::Freshness_value));
    write("fressssssssss_result is %llu",result_qword);
    if(sysGetVariableQWord(sysvar::Freshness_value) == result_qword && sysGetVariableInt(sysvar::Freshness_Byte0)-Current_Time[6] <= 2)
    {
      testStepPass("freshness value is equal to time0(t0)");
    }
    else
    {
      testStepFail("freshness value is not equal to time0(t0)");
    }
  
    
    for(i=0; i<7; i++)
    {
       write("Current_Time: 0x%X", Current_Time[i]);
    }
   
  }
  
  testWaitForTimeout(100);
  
  
  /* Read DID SOK_time_information */
  snprintf(BufferString, 100, "0x22 0x%02X 0x%02X",SOK_time_information[0],SOK_time_information[1]);
  sendDiagnosticsRequest(BufferString , "Read DID SOK_time_information");
  
  snprintf(BufferString, 100, "0x62 0x%02X 0x%02X %s",SOK_time_information[0],SOK_time_information[1],"Check positive response for SOK_time_information");
  TestExpectation(BufferString);
  SOK_checkDiagnosticsResponse_returnArray(Current_Time_2,14, 6 ,12 , 1000);
  
  if(product_name == Audi)
  {
          
    /*Wait for the ECU to sent a broadcast I-PDU according to the SOK-DFL*/
    sysSetVariableInt(sysvar::Time_flag_2 , 1);
    
    while(sysGetVariableInt(sysvar::Time_flag_2) != 2){testWaitForTimeout(500);
    testStep("","PDU not recieved!");}
    
    
    // Initialize the qword value to 0
    result_qword = 0;

    // Combine the bytes into the qword value
    for (i = 0; i < 6; ++i)
    {
        result_qword |= ((qword)Current_Time_2[i]) << (i * 8);
    }
    
    write("fressssssssss is %llu",sysGetVariableQWord(sysvar::Freshness_value));
    write("fressssssssss_result is %llu",result_qword);
    if(sysGetVariableQWord(sysvar::Freshness_value) == result_qword && sysGetVariableInt(sysvar::Freshness_Byte0)-Current_Time_2[6] <=2)
    {
      testStepPass("freshness value is equal to time1(t1)");
    }
    else
    {
      testStepFail("freshness value is not equal to time1(t1)");
    }
    
    for(i=0; i<7; i++)
    {
       write("Current_Time: 0x%X", Current_Time_2[i]);
    }
  }
  
  if(product_name == Audi)
  {
  flag_2 = 0;
  for(i=0; i<8; i++)
  {
    if(Current_Time[i] != Current_Time_2[i])
    {
      flag_2 = 1; 
    }
    
  }
  
  if(flag_2 == 1)
  {
    testStepPass("The t0 is not equal t1");
  }
  else
  {
    testStepFail("The t0 is equal t1");
  }
 }
}